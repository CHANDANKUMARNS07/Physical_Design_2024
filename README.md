# Physical_Design_2024
This is Chandan Kumar N S (MS2024007). <br/>
Course - Physical Design of ASICs ( VLS508) <br/>
# Outline
1.[LAB 1](#lab-1)<br/>
2.[LAB 2](#lab-2)<br/>
3.[LAB 3](#lab-3)<br/>
4.[LAB 4](#lab-4)<br/>
5.[LAB 5](#lab-5)<br/>
6.[LAB 6](#lab-6)<br/>
7.[LAB 7](#lab-7)<br/>
8.[LAB 8](#lab-8)<br/>
9.[LAB 9](#lab-9)<br/>
10.[LAB 10](#lab-10)<br/>
11.[LAB 11](#lab-11)<br/>
12.[LAB 12](#lab-12)<br/>

# LAB 1
  ## TASK 1
  ### Write a C Program and compile it on gcc compiler.
  This repository contains a simple C program that calculates the sum of n numbers. <br/>
  The following steps outline how to compile a C program using GCC. <br/>
  ## Step 1 

Open the terminal and ensure you are in the home directory. Launch any text editor to create a new file named 'file_name.c' for writing the C program. I have used the gedit editor.<br/>
## i. Code Snippet : 
``` c
#include<stdio.h>
int main(){
int i,n=100,sum=0;
for(i=0;i<=n;++i)
sum+=i;
}
printf("sum of numbers from 1 to %d is %d\n",n,sum);
return 0;
}
```
## Step 2
Save the program. Compile the code using the GCC compiler with the following command.<br/>
```
gcc file_name.c
```
## Output
The output can be viewed by opening the .out file. By default, the compiler creates a file named 'a.out' in the same directory. This name can be changed using the following command.<br/>
```
gcc -o output_filename.out filename.c
```
The below image shows the c program and also the output i got for different values of n which is 100, 15, 1000 and the result is saved in "output.out" file.<br/>
For verification we can use the mathematical formula for the sum of n numbers is : <br/>
Sum = (n(n+1))/2<br/>

![output](https://github.com/user-attachments/assets/ea37bd1b-cb44-4fad-9c2a-e77e7c5ce9c9)

## TASK 2
### Compiling the same C Program in RISC-V gcc compiler
The procedure for compiling a C program using RISC-V gcc compiler is as follows :<br/>
## Step 1
First, we display the content of our code. Next, using the command in figure, compile the code with the RISC-V gcc compiler. Running this command will generate an output file named filename.o
```
cat filename.c
riscv64-unknown-elf-gcc -O1 -mabi=lp64 -march=rv64i -o filename.o filename.c
ls -ltr filename.o
```
![riscv1](https://github.com/user-attachments/assets/771995a4-f216-4763-87c3-e18ecdd567fd)

## Step 2
Now using the command in figure, we'll get assembly code of our c programme. We'll get a bunch of code. We'll again run the same command adding | less in the end
```
riscv64-unknown-elf-objdump -d filename.o
riscv64-unknown-elf-objdump -d filename.o | less
```
![riscv2](https://github.com/user-attachments/assets/aa1acc2b-273c-4262-9751-e660543179a7)
## Step 3
We'll obtain the output. Since we are particularly interested in the main section, we'll focus on that segment. To count the number of instructions, subtract the address of the first instruction in the current section from the address of the first instruction in the next section. Divide the result by 4, as the increment is 4 at each step. This calculation will reveal that there are 15 sets of instructions when using the -O1 optimization level.

![ricv3](https://github.com/user-attachments/assets/6b5e54bc-4b35-478a-876c-5c228dd6dd12)

![calculator1](https://github.com/user-attachments/assets/b6eb3e66-38cf-4002-8161-ed9a4a5520a4)
## Step 4
Now change the formula from '-O1' to '-Ofast' as in step 1 and re compile using the same commands in the terminal.
```
riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o filename.o filename.c
ls -ltr filename.o
riscv64-unknown-elf-objdump -d filename.o
riscv64-unknown-elf-objdump -d filename.o | less
```
![riscv4](https://github.com/user-attachments/assets/0c684187-3cb7-49ee-9328-86cb0efd6b11)

When you calculate the number of instructions using the method described in step 3, you'll find that there are 12 instructions in this case.

![riscv5output](https://github.com/user-attachments/assets/2d950739-5552-4151-a7d3-61932aa325a5)

By comparing both -Ofast and -O1. -Ofast optimization level, the number of instructions is reduced. This is because -Ofast applies a broader range of aggressive optimizations that streamline the code, eliminate redundancies, and leverage parallelism, leading to a lower instruction count compared to -O1.

# LAB 2
## TASK 1
### Debbugging with Spike Simulator and Running the Object File Generated by RISC-V Compiler in Spike Simulator
The following are the steps to be followed. <br/>
## Step 1
Compile sum1ton.c (C source file) into sum1ton.o (Object file) for RISC-V with -Ofast optimization.
```
riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o sumton.o sumton.c
```
## Step 2
Get the Object dump using following command.
```
riscv64-unknown-elf-objdump -d sumton.o | less
```

![ris0](https://github.com/user-attachments/assets/8bd7ace0-1561-457c-b93d-22b69f448ff5)

We get the following output:

The assembly level of main section of the program sumoneton.c is shown below in the snapshot for reference.

![ris1](https://github.com/user-attachments/assets/ef052c00-d788-4b94-b853-416bcd40d409)

## Step 3
Again re-compile the c program using gcc compiler and spike simulator. We get the below shown output.

```
spike pk sumton.o
```

![ris2](https://github.com/user-attachments/assets/44c7da2e-0359-4ec6-87cb-80c657f112ce)

## Step 4
For debugging the code, we open debugger using spike.
```
 spike -d pk sum1ton.o
```
we want to run our program counter till 100b0
```
 until pc 0 100b0
```   
After the running of the commands manually after this, you must see "bbl loader", this ensures assembly code has run till 100b0 address now see the objdump to see what is the next instruction, in my case<br/>
* First command is lui a2, 0x7a which changes a2 register value<br/>

It allow the Spike debugger to run until the main function, specifically until the 100b0 instruction. After that, we will manually continue debugging and inspect the a2 register before and after the execution. We observe that the
instruction lui a2, 0x7a updates the a2 register from 0x0000000000000000 to 0x000000000007a000.<br/>
```
reg 0 a2
```
![ris3](https://github.com/user-attachments/assets/c1abdae1-72d2-41d3-bfa2-9f007047acd7)

* we will manually debug the next instruction i.e., lui a0, 0x21 and addi sp, sp, -16. This instruction decrements the stack pointer (sp) by 16. Before executing this instruction, the sp register held the value 0x0000003ffffffb50, which is then updated to 0x0000003ffffffb40.<br/>
 ```
reg 0 sp
```

* In the assembly code we can see that the value of the stack pointer is being reduced by 10 in hexadecimal we is equivalent to being reduced by 16 in decimal notation. 

![rrrrr](https://github.com/user-attachments/assets/cdc09ade-6cfa-4332-adfc-d184f9427662)

# LAB 3
## TASK 1
### To Identify various RISC-V instruction type (R, I, S, B, U, J) and exact 32-bit instruction code in the instruction type format for the given RISC-V instructions.
### Various format types of RISC-V instruction are:
- R-format
- I-format
- S-format
- B-format
- U-format
- J-format

<img width="772" alt="3808 1535301636" src="https://github.com/user-attachments/assets/d6bb6e93-1cd1-4a3f-8bc1-2841d8d30f11">

### 1. R Type :
Used for arithmetic and logical operations that involve only registers.
![R](https://github.com/user-attachments/assets/5615e6f4-648f-4e0f-a33c-0181d9859e80)

- `funct7` (7 bits): Specifies the function of the instruction (e.g., ADD, SUB).
- `rs2` (5 bits): Source register 2.
- `rs1` (5 bits): Source register 1.
- `funct3` (3 bits): Specifies the function within the operation.
- `rd` (5 bits): Destination register.
- `opcode` (7 bits): Operation code indicating the type of instruction

### 2. I Type :  
Used for instructions that include an immediate value or involve load operations.
![I](https://github.com/user-attachments/assets/13bdecb2-7b55-4c22-afba-7a6fdb8636c9)

- `imm[11:0]` (12 bits): Immediate value, sign-extended to 32 bits.
- `rs1` (5 bits): Source register 1.
- `funct3` (3 bits): Specifies the function of the instruction.
- `rd` (5 bits): Destination register.
- `opcode` (7 bits): Operation code

### 3. S Type : 
Used for store operations
![S](https://github.com/user-attachments/assets/fd39c8cc-0ef8-4745-bd62-a58428aa1d0e)

- `imm[11:5]` (7 bits): Upper part of the immediate value.
- `rs2` (5 bits): Source register 2.
- `rs1` (5 bits): Source register 1.
- `funct3` (3 bits): Specifies the function of the instruction.
- `imm[4:0]` (5 bits): Lower part of the immediate value.
- `opcode` (7 bits): Operation code.

### 4. B Type : 
Used for branch operations.
![B](https://github.com/user-attachments/assets/5faf17d8-47c5-4ae6-8e76-84951ea323ac)

- `imm[12]` (1 bit): Most significant bit of the immediate value.
- `imm[10:5]` (6 bits): Upper part of the immediate value.
- `rs2` (5 bits): Source register 2.
- `rs1` (5 bits): Source register 1.
- `funct3` (3 bits): Specifies the function of the instruction.
- `imm[4:1]` (4 bits): Lower part of the immediate value.
- `imm[11]` (1 bit): Sign bit of the immediate value.
- `opcode` (7 bits): Operation code

### 5. U Type :
Used for instructions involving upper immediate values
![U](https://github.com/user-attachments/assets/3e9c9d86-6e71-46dd-980b-6e048a3494ed)

- `imm[31:12]` (20 bits): Immediate value, shifted left 12 bits.
- `rd` (5 bits): Destination register.
- `opcode` (7 bits): Operation code

### 6. J Type :
Used for jump instructions.
![J](https://github.com/user-attachments/assets/350ce493-7c33-4bfd-8390-5422b3e94e90)

- `imm[19]` (1 bit): Most significant bit of the immediate value.
- `imm[10:1]` (10 bits): Lower part of the immediate value.
- `imm[11]` (1 bit): Sign bit of the immediate value.
- `imm[18:12]` (7 bits): Upper part of the immediate value.
- `rd` (5 bits): Destination register.
- `opcode` (7 bits): Operation code.

## RISC-V instruction types and the corresponding 32-bit instruction codes for the provided instructions:<br/>

| S. No. | Assembly Instruction | Instruction format |         32 bit Instruction Code as per the type of format       | Hexadecimal representation|
|--------|----------------------|--------------------|----------------------------------------|---------------------------|
| 1.     | ADD r11, r12, r13       | R                  |0000000 01101 01100 000 01011 0110011  |        0x00D605B3         |
| 2.     | SUB r13, r11, r12       | R                  | 0100000 01100 01011 000 01101 0110011  |        0x40C586B3         |
| 3.     | AND r12, r11, r13       | R                  | 0000000 01101 01011 111 01100 0110011  |        0x00D5F633         |
| 4.     | OR r8, r12, r5        | R                  | 0000000 00101 01100 110 01000 0110011 |        0x00566433         |
| 5.     | XOR r8, r11, r4       | R                  | 0000000 00100 01011 100 01000 0110011 |        0x0045C433        |
| 6.     | SLT r30, r20, r4      | R                  | 0000000 00100 10100 010 11110 0110011  |        0x004A2F33         |
| 7.     | ADDI r31, r21, 5      | I                  | 000000000101 10101 000 11111 0010011   |        0x005A8F93         |
| 8.     | SW r21, r19, 4         | S                  | 0000000 10101 10011 010 00100 0100011  |        0x0159A223         |
| 9.     | SRL r26, r21, r20     | R                  | 0000000 10100 10101 101 11010 0110011  |        0x014ADD33         |
| 10.    | BNE r0, r19, 20       | B                  | 0 000000 10011 00000 001 0100 0 1100011  |        0x01301463         |
| 11.    | BEQ r0, r0, 15       | B                  | 0 000000 00000 00000 000 1111 0 1100011  |        0x00000F63         |
| 12.    | LW r23, r21, 2       | I                  | 000000000010 10101 010 10111 0000011   |        0x002AAB83         |
| 13.    | SLL r25, r21, r20     | R                  | 0000000 10100 10101 001 11001 0110011  |        0x014A9CB3         |

## TASK 2
### By making use of RISCV Core: Verilog Netlist and Testbench, perform an experiment of Functional Simulation.

Table to show standard RISC-V ISA and Hardcore ISA for each operation that takes place in the given code:<br/>

|  **Instructions**  |  **Standard RISCV ISA**  |  **Hardcoded ISA**  |  
  |  :----:  |  :----:  |  :----:  |  
  |  ADD R6, R2, R1  |  32'h00110333  |  32'h02208300  |  
  |  SUB R7, R1, R2  |  32'h402083b3  |  32'h02209380  |  
  |  AND R8, R1, R3  |  32'h0030f433  |  32'h0230a400  |  
  |  OR R9, R2, R5  |  32'h005164b3  |  32'h02513480  |  
  |  XOR R10, R1, R4  |  32'h0040c533  |  32'h0240c500  |  
  |  SLT R1, R2, R4  |  32'h0045a0b3  |  32'h02415580  |  
  |  ADDI R12, R4, 5  |  32'h004120b3  |  32'h00520600  |  
  |  BEQ R0, R0, 15  |  32'h00000f63  |  32'h00f00002  |  
  |  SW R3, R1, 2  |  32'h0030a123  |  32'h00209181  |  
  |  LW R13, R1, 2  |  32'h0020a683  |  32'h00208681  |  
  |  SRL R16, R14, R2  |  32'h0030a123  |  32'h00271803  |
  |  SLL R15, R1, R2  |  32'h002097b3  |  32'h00208783  |  


From below we can see all instructions are Hardcoded as per the verilog code given.<br/>

![mem](https://github.com/user-attachments/assets/73df5dd7-e6eb-49c9-a49e-dc1078137164)

To compile and to get gtkwave of the iiitb_rv32i.v file and it's testbench iiitb_rv32i_tb.v file use below commands:<br/>

1. Create a new directory:
   ```
   mkdir risc_v_sim
   cd risc_v_sim
   ```

2. Create Verilog and testbench files:
   ```
   touch rv32i.v rv32i_tb.v
   ```

3. Copy RISC-V core and testbench code from the [reference repository](https://github.com/vinayrayapati/rv32i/).

4. Run simulation:
   ```
   iverilog -o rv32i rv32i.v rv32i_tb.v
   ./rv32i
   ```

5. View waveforms:
   ```
   gtkwave iiitb_rv32i.vcd
   ```
   ![terminal_1](https://github.com/user-attachments/assets/94ff016f-7cc9-409a-9a03-d937ce670a79)
   ![terminal_2](https://github.com/user-attachments/assets/8d284c8c-b045-4c22-9921-3f072c4ef663)
   
   ## Analyzing the Output Waveform of Instructions Covered:

## - **Instruction 1: ADD r6, r1, r2**

![add](https://github.com/user-attachments/assets/e6bf4a03-4b55-43ca-8a0c-5b794f222660)

## - **Instruction 2: SUB r7, r1, r2**

![sub](https://github.com/user-attachments/assets/9f0f3673-e5c3-4d57-b0aa-f7ed12b060f3)

## - **Instruction 3: AND r8, r1, r3**

![and](https://github.com/user-attachments/assets/a3a24aae-acdc-4751-a5e5-2ae194c46b17)


## - **Instruction 4: OR r9, r2, r5**

![or](https://github.com/user-attachments/assets/8e2c1a53-0fbf-4272-989c-2bc6d0edf034)

## - **Instruction 5: XOR r10, r1, r4**

![xor](https://github.com/user-attachments/assets/e58cab92-4ec8-42be-8e6b-df7848a47d76)

## - **Instruction 6: SLT r11, r2, r4**

![slt](https://github.com/user-attachments/assets/53de8aa4-7158-4137-b192-86466ecff448)

## - **Instruction 7: ADDI r12, r4, 5**

![addi](https://github.com/user-attachments/assets/39ad3858-c7eb-4289-9007-b63b022d6f4b)

## - **Instruction 8: SW r3, r1, 2**

![sw](https://github.com/user-attachments/assets/5a682334-9eba-4c50-ab10-2b48cb9ce14b)

## - **Instruction 9: LW r13, r1, r2**

![lw](https://github.com/user-attachments/assets/920e66b4-4655-46ef-8702-335a079366b5)

## - **Instruction 10: BEQ r0, r0, 15**

![beq](https://github.com/user-attachments/assets/503118d8-816e-4180-a4b0-59292315d299)

## - **Instruction 11: ADD r14, r2, 2**

![add1](https://github.com/user-attachments/assets/941e1196-7333-446f-aa9a-72e98dfb52fb)

## - **Instruction 12: BNE r0,r1,20**
After uncommenting the above instruction line we get this type of output but as we haven't mention any values to perform the operation this doesn't show any output.<br/>

![bne](https://github.com/user-attachments/assets/243f6c90-562f-4e21-90d2-a5704ba1c5e0)

### - **Instruction 13: ADDI r12,r4,5**
### - **Instruction 14: SLL r15,r1,r2**
### - **Instruction 15: SRL r16, r14, r2**

As i did the same thing by uncommenting these instructions 13, 14, 15 to get the output i got the below error saying that their is a not enough space for executing it.<br/>
                                                                                                                                                                          
![error thing](https://github.com/user-attachments/assets/73b911de-e825-419b-90d8-50558bfa55fd)

 

This experiment demonstrated the functional simulation of various RISC-V instructions using a Verilog netlist and testbench. We observed the behavior of each instruction through waveform analysis, providing insights into the RISC-V core's operation.<br/>

The comparison between standard RISC-V ISA encoding and the hardcoded ISA used in the simulation highlights the differences in instruction representation, which is crucial for understanding the implementation details of this particular RISC-V core. <br/> 

# LAB 4

## Compiling a C code of real life application with GCC and RISC-V GCC and also with SPIKE simulator.
## Password Strength Checker
A simple C program to evaluate and display the strength of a given password based on length, character diversity, and complexity. Useful for integrating basic security checks in applications requiring user authentication.<br/>
## i. Code Snippet:
```
#include <stdio.h>
#include <ctype.h>
#include <string.h>

#define MIN_LENGTH 8

int isStrongPassword(const char *password) {
    int hasUpper = 0, hasLower = 0, hasDigit = 0, hasSpecial = 0;
    const char specialChars[] = "!@#$%^&*()-_+=<>?/[]{}|";
    
    // Check the length
    if (strlen(password) < MIN_LENGTH) {
        return 0; // Password too short
    }

    // Check for required character types
    for (int i = 0; password[i] != '\0'; i++) {
        if (isupper(password[i])) {
            hasUpper = 1;
        } else if (islower(password[i])) {
            hasLower = 1;
        } else if (isdigit(password[i])) {
            hasDigit = 1;
        } else {
            for (int j = 0; specialChars[j] != '\0'; j++) {
                if (password[i] == specialChars[j]) {
                    hasSpecial = 1;
                    break;
                }
            }
        }
    }

    return hasUpper && hasLower && hasDigit && hasSpecial;
}

int main() {
    char password[100];
    
    printf("Enter your password: ");
    scanf("%99s", password);
    
    if (isStrongPassword(password)) {
        printf("Your password is strong.\n");
    } else {
        printf("Your password is weak. It should be at least %d characters long, and include:\n", MIN_LENGTH);
        printf("- At least one uppercase letter\n");
        printf("- At least one lowercase letter\n");
        printf("- At least one digit\n");
        printf("- At least one special character (eg. *!)\n");
    }

    return 0;
}
```
## ii. Save the program. Compile the code using the GCC compiler with the following command.<br/>
```
gcc file_name.c
```
## Output
The output can be viewed by opening the .out file. By default, the compiler creates a file named 'a.out' in the same directory. This name can be changed using the following command.<br/>
```
gcc -o output_filename.out filename.c
```
The below image shows the output and the result is saved in "output.out" file.<br/>

![1](https://github.com/user-attachments/assets/a2673885-5b93-4c36-852a-2756b69a5454)

## iii. Now, compile the program using RISC-V gcc compiler and also with SPIKE Simulator
The procedure for compiling a C program using RISC-V gcc compiler is as follows :<br/>

```
riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o filename.o filename.c
ls -ltr filename.o
```
Now using the command in figure, we'll get assembly code of our c programme. We'll get a bunch of code. 
```
riscv64-unknown-elf-objdump -d filename.o
riscv64-unknown-elf-objdump -d filename.o | less
```
![4](https://github.com/user-attachments/assets/3581916d-c7d6-44cc-8962-4342c6077f8b)

We get the following output:<br/>

The assembly level of main section of the program application.c is shown below in the snapshot for reference.

![2(1)](https://github.com/user-attachments/assets/ecf04561-dd3d-46a8-a2a6-529d9fdc1289)

Again re-compile the c program using gcc compiler and spike simulator. We get the below shown output.<br/>

```
spike pk filename.o
```
![5()1](https://github.com/user-attachments/assets/909170dc-d02c-4896-9a99-00802ce49af8)
![5](https://github.com/user-attachments/assets/58149016-d927-4c8a-b766-61b46398d399)

Concluding that in both GCC and RISCV-GCC using SPIKE simulator we can say that we get the same result. 

# LAB 5

## Digital Logic with TL-Verilog in Makerchip IDE
### MAKERCHIP 
[Makerchip](https://makerchip.com/) is a free online environment for developing high-quality integrated circuits. You can code, compile, simulate, and debug Verilog designs, all from your browser. Your code, block diagrams, and waveforms are tightly integrated.<br/>

### TL VERILOG  
Transaction Level Verilog or TL-Verilog is an extension to existing Verilog HDL and a huge step forward in coding HDL languages. TL-Verilog introduces simpler syntaxes and adds powerful constructs which makes Logic Design fun and easy. (Also can say its a Higher Abstraction to Sys V). Generally, high-speed designs are less than half the size in TL-Verilog versus SystemVerilog without any loss in detail! More about it [here](https://www.redwoodeda.com/tl-verilog)<br/>

### DIGITAL DESIGN
Below are a set of images from Makerchip showcasing the TL-V code for Combinational and sequential logic and Simulation Output. Most of the basic circuits examples can be found in Makerchip Tutorials anexhaustive list to get anyone enough information to learn the platform and TL-Verilog.<br/>

### LOGIC GATES

Logic gates are the fundamental building blocks of digital circuits. They perform basic logical functions that are essential in computing and digital systems. Each gate takes one or more binary inputs and produces a single binary output, following a specific logic rule.<br/>

1. AND Gate: Outputs 1 only when all its inputs are 1.<br/>
2. OR Gate: Outputs 1 if at least one of its inputs is 1.<br/>
3. NOT Gate (Inverter): Outputs the opposite of the input; 1 becomes 0, and 0 becomes 1.<br/>
4. NAND Gate: Outputs 0 only when all its inputs are 1. It is the inverse of the AND gate.<br/>
5. NOR Gate: Outputs 0 if at least one of its inputs is 1. It is the inverse of the OR gate.<br/>
6. XOR Gate: Outputs 1 only when the number of 1 inputs is odd.<br/>
7. XNOR Gate: Outputs 1 only when the number of 1 inputs is even, making it the inverse of the XOR gate.<br/>
These gates are used in combination to create complex circuits like adders, multiplexers, and memory units, forming the foundation of all digital electronics.<br/>
The below shown image are the logic gates<br/>
![image](https://github.com/user-attachments/assets/bebf58a9-7d4f-4be1-8bdf-217cdf4bef35)

### COMBINATIONAL CIRCUITS
Combinational circuits are digital circuits where the output depends solely on the current inputs, without any memory or feedback loops. They perform specific logical operations like addition, subtraction, or comparison using logic gates. Common examples include multiplexers, demultiplexers, adders, and encoders, which are integral in processing and controlling data in digital systems.<br/>

### BASIC COMBINATIONAL CIRCUITS IN MAKERCHIP

1. Pythagorean example<br/>
```
\m4_TLV_version 1d: tl-x.org
\SV
   `include "sqrt32.v";
   
   m4_makerchip_module
\TLV
   
   // Stimulus
   |calc
      @0
         $valid = & $rand_valid[1:0];  // Valid with 1/4 probability
                                       // (& over two random bits).
   
   // DUT (Design Under Test)
   |calc
      ?$valid
         @1
            $aa_sq[7:0] = $aa[3:0] ** 2;
            $bb_sq[7:0] = $bb[3:0] ** 2;
         @2
            $cc_sq[8:0] = $aa_sq + $bb_sq;
         @3
            $cc[4:0] = sqrt($cc_sq);


   // Print
   |calc
      @3
         \SV_plus
            always_ff @(posedge clk) begin
               if ($valid)
                  \$display("sqrt((\%2d ^ 2) + (\%2d ^ 2)) = \%2d", $aa, $bb, $cc);
            end

\SV
   endmodule
```
![pythagoras_theorem](https://github.com/user-attachments/assets/d6acc6c2-4d86-4af6-ba49-f1d1b518b204)

3. Inverter<br/>
```
$out = ~$in1;
```
![inv_code](https://github.com/user-attachments/assets/63ff7acc-1f52-4b9c-af55-4f12e149b6dd)

![inv_wave](https://github.com/user-attachments/assets/ff7f9d50-968c-43b8-851a-f0cb24b31681)

4. Vectors<br/>

```
$out[4:0] = $in1[3:0] + $in2[3:0] ;

```
![a+b](https://github.com/user-attachments/assets/76935524-cf08-4d1e-96b7-e2858b1368f9)

6. Multiplexer<br/>

![image](https://github.com/user-attachments/assets/872acaa4-552f-46c3-ac2a-332bf5f25f04)

 ```
   $out[7:0] = $sel ? $in1[7:0] : $in2[7:0] ;
 ```
 ![mux](https://github.com/user-attachments/assets/f16c999b-b578-4838-8c75-b51ca7558729)

7. Combinational Calculator<br/>

![image](https://github.com/user-attachments/assets/8fe3ecfe-74b0-447a-8bfa-2411b3b68aaf)

![calc_comb](https://github.com/user-attachments/assets/23474aa2-f095-496c-9ae7-259c2c64b45b)
![calc_comb_diagram](https://github.com/user-attachments/assets/ff3585a6-fc09-4bf8-aee6-74038ebc2aa6)
  

### SEQUENTIAL CIRCUITS
Sequential circuits are digital circuits where the output depends on both the current inputs and the history of past inputs, using memory elements like flip-flops. They are used to design systems like counters, registers, and finite state machines, which require storage and timing elements.<br/>

### Sequential Logic<br/>
![image](https://github.com/user-attachments/assets/372b159f-5011-4c90-a6a6-baf5f9244e91)

### BASIC SEQUENTIAL CIRCUITS IN MAKERCHIP

1. Fibonacci Series with reset<br/>

![image](https://github.com/user-attachments/assets/6b256b8f-45bf-4abc-a913-c45878fcb6ab)
```
$num[15:0] = $reset ? 1 : (>>1$val + >>2$val) ;
```
![fibo](https://github.com/user-attachments/assets/59dc9aa3-e4aa-4bdc-882c-cc54b2148e37)

2. Free running counter<br/>

![image](https://github.com/user-attachments/assets/0a465f97-e4e5-40c0-8215-fbd1245a4999)
```
$num[15:0] = $reset ? 0 : (1+>>1$val) ;
```
![free running counter](https://github.com/user-attachments/assets/b74be74f-f61b-432d-a6fa-7acf0d814de3)

3. Sequential Calculator<br/>

![image](https://github.com/user-attachments/assets/c39ffdf6-e3c5-466a-beb3-da014ceb5ac9)

![calc_seq](https://github.com/user-attachments/assets/d1cba3cb-313b-4bd0-9b74-ff1eddabe801)
![calc_seq_waveform](https://github.com/user-attachments/assets/bacb09cd-1c48-4735-a633-ba5fea1ee872)

### PIPELINING

![image](https://github.com/user-attachments/assets/ab28d225-8ccb-4f85-99f5-48f98d5388b5)<br/>

1. Pythagoras theorem for timing abstract <br/>

i. 4 cycles<br/>

![pyth_4cycles](https://github.com/user-attachments/assets/5d882b2f-5d17-4d13-8595-acf9cd95ea31)

ii. 12 cycles<br/>

![pyth_12cycles](https://github.com/user-attachments/assets/b53ba172-56f6-4800-9b66-19752ea8d531)

2. Counter and Calculator in Pipeline<br/>

![image](https://github.com/user-attachments/assets/ebca88aa-1279-462e-9a30-1bb62d57da08)
```
\m4_TLV_version 1d: tl-x.org
\SV

   // =========================================
   // Welcome!  Try the tutorials via the menu.
   // =========================================

   // Default Makerchip TL-Verilog Code Template
   
   m4_include_lib //(['https://raw.githubusercontent.com/stevehoover/RISC-V_MYTH_Workshop/bd1f186fde018ff9e3fd80597b7397a1c862cf15/tlv_lib/calculator_shell_lib.tlv'])

\SV   
   // Macro providing required top-level module definition, random
   // stimulus support, and Verilator config.
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
   //m4+cal_viz(@3)
\TLV
   |calc
      @0
         $reset = *reset;
      @1
         $val1[31:0]  =  >>1$out;
      // $val1[31:0]  = $rand1[3:0];
         $val2[31:0]  = $rand2[3:0];
         $op[1:0]    = $rand1[1:0];
         $sum[31:0]   = $val1 + $val2;
         $sub[31:0]   = $val1 - $val2;
         $mul[31:0]   = $val1 * $val2;
         $quotient[31:0] = $val1 / $val2;
         $out[31:0]  = $reset? 0 :  ($op[1]? ($op[0]? ($sum) : ($sub)): ($op[0]? ($mul) : ($quotient))); 
         $count[31:0] = $reset? 0 :  (>>1$count+1);
        m4+cal_viz(@3) // Arg: Pipeline stage represented by viz, should be atleast equal to last stage of CALCULATOR logic.           
      // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
\SV
   endmodule
```
![cnt_cal_single_pipeline](https://github.com/user-attachments/assets/c00ea84d-473c-47a6-af9e-13ebfbdea8c4)
![cnt_cal_single_pipelinewaveform](https://github.com/user-attachments/assets/f67c4ef4-6d1e-45fb-9a62-763b393f7a49)

3. 2-Cycle Calculator<br/>

![image](https://github.com/user-attachments/assets/eeea5799-67b6-41c0-aa5f-9a4895d4634a)
```
\m4_TLV_version 1d: tl-x.org
\SV

   // =========================================
   // Welcome!  Try the tutorials via the menu.
   // =========================================

   // Default Makerchip TL-Verilog Code Template
   
   m4_include_lib(['https://raw.githubusercontent.com/stevehoover/RISC-V_MYTH_Workshop/bd1f186fde018ff9e3fd80597b7397a1c862cf15/tlv_lib/calculator_shell_lib.tlv'])

\SV   
   // Macro providing required top-level module definition, random
   // stimulus support, and Verilator config.
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
   //m4+cal_viz(@3)
\TLV
   |calc
      @0
         $reset = *reset;
      @1
         $val2[31:0]  = $rand2[3:0];
        // $op[1:0]     = $rand1[1:0];
         $valid = $reset? 0 :  (>>1$valid+1);
         
         $val1[31:0]  =  >>2$out;            
                   
                  // $val1[31:0]  = $rand1[3:0];
         $sum[31:0]   = $val1 + $val2;
         $sub[31:0]   = $val1 - $val2;
         $mul[31:0]   = $val1 * $val2;
         $quotient[31:0] = $val1 / $val2;
            
      @2
         $valid_reset = ($reset || (!($valid)));   
         $out[31:0]  = $valid_reset ? 0 : ($op[1] ? ($op[0] ? $sum : $sub): ($op[0] ? $mul : $quotient )); 

  // m4+cal_viz(@2) // Arg: Pipeline stage represented by viz, should be atleast equal to last stage of CALCULATOR logic.           
      // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
\SV
   endmodule
```
![calc_double_cycle_pipeline](https://github.com/user-attachments/assets/fb67ce31-a84a-4773-ae89-f8c9e501f0c1)
![calc_double_cycle_pipeline_waveform](https://github.com/user-attachments/assets/5077f0ad-3909-416e-80f5-85ced81b6916)

### VALIDITY

1. 2-Cycle Calculator with Validity<br/>

![image](https://github.com/user-attachments/assets/6922e206-dd89-4c17-b9e2-ad9d3228f1d6)

```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/stevehoover/RISC-V_MYTH_Workshop/bd1f186fde018ff9e3fd80597b7397a1c862cf15/tlv_lib/calculator_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)

\TLV   
   |calc
      @0
         $reset = *reset;
         $clk_chandan = *clk;
      @1
         $val1 [31:0] = >>2$out [31:0];
         $val2 [31:0] = $rand2[3:0];
         
         $valid = $reset ? 1'b0 : >>1$valid + 1'b1 ;
         $valid_or_reset = $valid || $reset;
         
      ?$vaild_or_reset
         @1   
            $sum [31:0] = $val1 + $val2;
            $diff[31:0] = $val1 - $val2;
            $prod[31:0] = $val1 * $val2;
            $quot[31:0] = $val1 / $val2;
            
         @2   
            $out [31:0] = $reset ? 32'b0 :
                          ($op[1:0] == 2'b00) ? $sum :
                          ($op[1:0] == 2'b01) ? $diff :
                          ($op[1:0] == 2'b10) ? $prod :
                                                $quot ;
            
            

      // Macro instantiations for calculator visualization(disabled by default).
      // Uncomment to enable visualisation, and also,
      // NOTE: If visualization is enabled, $op must be defined to the proper width using the expression below.
      //       (Any signals other than $rand1, $rand2 that are not explicitly assigned will result in strange errors.)
      //       You can, however, safely use these specific random signals as described in the videos:
      //  o $rand1[3:0]
      //  o $rand2[3:0]
      //  o $op[x:0]
      
   //m4+cal_viz(@3) // Arg: Pipeline stage represented by viz, should be atleast equal to last stage of CALCULATOR logic.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   

\SV
   endmodule
```
![cycle_calc_with_validity](https://github.com/user-attachments/assets/d8bc618f-d811-4f04-a15b-1006f91b93cc)
![cycle_calc_with_validitywaveform](https://github.com/user-attachments/assets/d54e9a10-3dea-48e0-8a86-6fe5e371b31e)

2. Calculator with Single-Value Memory<br/>

![image](https://github.com/user-attachments/assets/1de62422-4402-4356-9519-3cc5784c70a9)
```
\m4_TLV_version 1d: tl-x.org
\SV

   // =========================================
   // Welcome!  Try the tutorials via the menu.
   // =========================================

   // Default Makerchip TL-Verilog Code Template
   
   m4_include_lib(['https://raw.githubusercontent.com/stevehoover/RISC-V_MYTH_Workshop/bd1f186fde018ff9e3fd80597b7397a1c862cf15/tlv_lib/calculator_shell_lib.tlv'])

\SV   
   // Macro providing required top-level module definition, random
   // stimulus support, and Verilator config.
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
   //m4+cal_viz(@3)
\TLV
   |calc
      @0
         $reset = *reset;
      @1
         $val2[31:0]  = $rand2[3:0];
        // $op[1:0]     = $rand1[1:0];
         $valid = ($reset)? 0 :  (>>1$valid+1);
         
         $val1[31:0]  =  >>2$out;            
                   
                  // $val1[31:0]  = $rand1[3:0];
         $sum[31:0]   = $val1 + $val2;
         $sub[31:0]   = $val1 - $val2;
         $mul[31:0]   = $val1 * $val2;
         $quotient[31:0] = $val1 / $val2;
            
      @2
         $valid_reset = ($reset || (!($valid)));   
         $mem[31:0]   = ($reset)?  0 : (($op[2:0] == 3'b101)?  $val1 : >>2$mem) ;
         $out[31:0]   =  ($reset)? 32'b0 :
                         ($op[2:0] == 3'b000)? $quotient :
                         ($op[2:0] == 3'b001)? $mul :
                         ($op[2:0] == 3'b010)? $sub :
                         ($op[2:0] == 3'b011)? $sum :
                         ($op[2:0] == 3'b100)? >>2$mem : >>2$out ;  

   m4+cal_viz(@2) // Arg: Pipeline stage represented by viz, should be atleast equal to last stage of CALCULATOR logic.           
      // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
\SV
   endmodule
```
![cal_single_valuememory](https://github.com/user-attachments/assets/ae75f110-6e54-4320-b688-754a86cf274a)
![calcsinglevaluememorywaveform_1](https://github.com/user-attachments/assets/cf54b383-930b-46ef-8f76-de2eeb70e175)
![calcsinglevaluememorywaveform_2](https://github.com/user-attachments/assets/538dffc4-5201-43c4-9b8d-ca0b265ecd6c)
![calcsinglevaluememorywaveform_3](https://github.com/user-attachments/assets/151092e5-71bd-44fe-913e-11ca2b245157)

### HIERARCHY

3D Distance Calculation<br/>

using pythagorean example<br/>

![image](https://github.com/user-attachments/assets/2dd25f90-ac31-4b7a-8bbd-d01dae70ee77)

![image](https://github.com/user-attachments/assets/07cf520a-ce77-49fb-92b4-16703d45dbf7)


# LAB 6

## RISC-V Core Implementation

This section will cover the implementation of a simple 3-stage RISC-V Core / CPU. The 3-stages broadly are: Fetch, Decode and Execute. The diagram below is the basic block of the CPU core.<br/>
![image](https://github.com/user-attachments/assets/594fafcd-11b8-46f4-9b7e-3d74dd4c22a6)

### RISC-V Shell Code

The basic TL verilog code for sum 1 to 9 

```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;



      // YOUR CODE HERE
      // ...

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      //m4+imem(@1)    // Args: (read stage)
      //m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)

   //m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule
```

### 1. Program Counter
PC basically used for pointing out the executing out the current instruction execution and it will have next instruction which is to be executed.<br/>
![image](https://github.com/user-attachments/assets/c8e18655-ccbf-4073-8cf0-096a9b96d0ac)

```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;


     

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      //m4+imem(@1)    // Args: (read stage)
      //m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)

   //m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule
```
![pc](https://github.com/user-attachments/assets/ed16a369-5c2a-44d6-bab8-5b61a8a65fde)
![pc_waveform](https://github.com/user-attachments/assets/18010ee0-893d-4cf1-a29b-932f562c5380)

### 2. Fetch_1
The instruction fetch unit (IFU) in a central processing unit (CPU) is responsible for organising program instructions to be fetched from memory, and executed, in an appropriate order. This makes the control logic of the core.<br/>

![image](https://github.com/user-attachments/assets/54e60e02-46c8-4fd0-abef-b419da28c9b8)

Uncomment //m4+imem(@1), and //m4+cpu_viz(@4) compile.<br/>
errors.<br/>

```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;


    
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      //m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)

   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule
```
![fetch](https://github.com/user-attachments/assets/55532c00-9824-4c64-a536-815df6229337)


### Fetch_2

![image](https://github.com/user-attachments/assets/845f9629-3349-4f11-8657-ca47ec4f2c44)

For the same pc code add the IMEM_rd inputs and outputs.<br/>

```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;
      @1 
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
      ?$imem_rd_en
         @1
            $imem_rd_data[31:0] = /imem[$imem_rd_addr]$instr;  

      

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      //m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)

   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule
```
![fetch2](https://github.com/user-attachments/assets/caa14e8a-4738-493a-9b59-6db8d2e0e069)
![fetch2viz](https://github.com/user-attachments/assets/e750549e-2615-4db7-b37a-ac5bd163c856)

### 3. Decode

![image](https://github.com/user-attachments/assets/bea3a626-c8cc-4d93-8087-f09ccc01eb1f)

6 types of Instructions type decode:<br/>

* R-type - Register
* I-type - Immediate
* S-type - Store
* B-type - Branch (Conditional Jump)
* U-type - Upper Immediate
* J-type - Jump (Unconditional Jump)

![image](https://github.com/user-attachments/assets/9fd0c6a5-8e0a-495c-ac92-2c805f2ccedc)

 Instruction Decode<br/>
![image](https://github.com/user-attachments/assets/5e48a225-6b83-4339-ba16-c81dcf9fdef9)

Immediate Decode<br/>

![image](https://github.com/user-attachments/assets/acd87978-37c7-4bb5-b721-a497c3df8f2a)

```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;
      @1 
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
      ?$imem_rd_en
         @1
            $imem_rd_data[31:0] = /imem[$imem_rd_addr]$instr;  
         
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
      

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      //m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)

   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule
```
![decode_inst_type_imm](https://github.com/user-attachments/assets/0fad7606-ece9-4cbd-ac04-d3eed0ef2808)

Instruction Field Decode<br/>

![image](https://github.com/user-attachments/assets/4b7c0e74-b775-4cc7-ab82-0f3a498dcf63)

```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;
      @1 
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
      ?$imem_rd_en
         @1
            $imem_rd_data[31:0] = /imem[$imem_rd_addr]$instr;  
         
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
         
         //INSTRUCTION DECODE
         $rs2[4:0] = $instr[24:20];
         
         
         //INSTRUCTION FIELD DECODE
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         $opcode_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr || $is_b_instr || $is_s_instr;
         ?$opcode_valid
            $opcode[6:0] = $instr[6:0];
      

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      //m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)

   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule
```
![inst_decode_field_code](https://github.com/user-attachments/assets/7509bf57-0f14-46da-a275-004504254e31)
![inst_decode_field_diagram](https://github.com/user-attachments/assets/5fef41e0-4ccd-4575-8e0f-85db7fec565c)

RV32I Base Instruction Set

![image](https://github.com/user-attachments/assets/7f70e32b-81fa-4356-a2c9-d935646b2245)


```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;
      @1 
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
      ?$imem_rd_en
         @1
            $imem_rd_data[31:0] = /imem[$imem_rd_addr]$instr;  
         
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
         
         
         //INSTRUCTION DECODE
         $rs2[4:0] = $instr[24:20];
         
         
         //INSTRUCTION FIELD DECODE
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         $opcode_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr || $is_b_instr || $is_s_instr;
         ?$opcode_valid
            $opcode[6:0] = $instr[6:0];
         
         //INSTRUCTION DECODE
         $dec_bits [10:0] = {$funct7[5], $funct3, $opcode};
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         
         `BOGUS_USE ($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add)
         
      

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      //m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)

   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule
```
![inst_decode_code](https://github.com/user-attachments/assets/b059652d-cd75-474a-87d1-493bb16f25ae)

![inst_decode_dia](https://github.com/user-attachments/assets/7d5f246d-f260-4bef-9107-97c14b01c816)

### 4. Reg File read_1

![image](https://github.com/user-attachments/assets/4ec916e0-a98a-4396-9c1e-22ab7f0201f7)


Here the Register file is 2 read, 1 write which means 2 read and 1 write operation can happen simultanously.

Inputs:

* Read_Enable - Enable signal to perform read operation
* Read_Address1 - Address1 from where data has to be read
* Read_Address2 - Address2 from where data has to be read
* Write_Enable - Enable signal to perform write operation
* Write_Address - Address where data has to be written
* Write_Data - Data to be written at Write_Address
  
Outputs:

* Read_Data1 - Data from Read_Address1
* Read_Data2 - Data from Read_Address2

![image](https://github.com/user-attachments/assets/d4b1ff71-e6d4-4a38-9f90-d1b2049869b4)

In this the outputs are not added.<br/>

```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;
      @1 
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
      ?$imem_rd_en
         @1
            $imem_rd_data[31:0] = /imem[$imem_rd_addr]$instr;  
         
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
         
         
         //INSTRUCTION DECODE
         $rs2[4:0] = $instr[24:20];
         
         
         //INSTRUCTION FIELD DECODE
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         $opcode_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr || $is_b_instr || $is_s_instr;
         ?$opcode_valid
            $opcode[6:0] = $instr[6:0];
         
         //INSTRUCTION DECODE
         $dec_bits [10:0] = {$funct7[5], $funct3, $opcode};
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         
         `BOGUS_USE ($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add)
         
         //REGISTER FILE READ
         $rf_wr_en = 1'b0;
         $rf_wr_index[4:0] = 5'b0;
         $rf_wr_data[31:0] = 32'b0;
         $rf_rd_en1 = $rs1_valid;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_valid;
         $rf_rd_index2[4:0] = $rs2;
      

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)

   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule
```
![reg_file_read_code](https://github.com/user-attachments/assets/88179799-51b3-49cd-9246-fa5cc98095b0)
![reg_file_read_dia](https://github.com/user-attachments/assets/f02a2ea5-9d3f-4d54-8f94-a80ebce53a4f)

### Reg file read_2

In this the outputs are added.<br/>

```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;
      @1 
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
      ?$imem_rd_en
         @1
            $imem_rd_data[31:0] = /imem[$imem_rd_addr]$instr;  
         
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
         
         
         //INSTRUCTION DECODE
         $rs2[4:0] = $instr[24:20];
         
         
         //INSTRUCTION FIELD DECODE
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         $opcode_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr || $is_b_instr || $is_s_instr;
         ?$opcode_valid
            $opcode[6:0] = $instr[6:0];
         
         //INSTRUCTION DECODE
         $dec_bits [10:0] = {$funct7[5], $funct3, $opcode};
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         
         `BOGUS_USE ($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add)
         
         //REGISTER FILE READ
         $rf_wr_en = 1'b0;
         $rf_wr_index[4:0] = 5'b0;
         $rf_wr_data[31:0] = 32'b0;
         $rf_rd_en1 = $rs1_valid;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_valid;
         $rf_rd_index2[4:0] = $rs2;
         //output of rf
         $src1_value[31:0] = $rf_rd_data1;
         $src2_value[31:0] = $rf_rd_data2;

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)

   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule
```
![rf_read_withoutput_code](https://github.com/user-attachments/assets/3afbb8b3-a32d-4cd2-b269-74940809bd13)
![rf_read_withoutput_dia](https://github.com/user-attachments/assets/09fa4436-9be6-4907-81e4-94fdffef7c5e)

### 5. ALU
![image](https://github.com/user-attachments/assets/6900cfb1-2e7a-456f-be42-7ca9d807f1f6)

During the execute stage at ALU, both the operands perform the operation based on opcode. Below is snapshot from Makerchip IDE after performing the execute stage.<br/>


```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;
      @1 
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
      ?$imem_rd_en
         @1
            $imem_rd_data[31:0] = /imem[$imem_rd_addr]$instr;  
         
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
         
         
         //INSTRUCTION DECODE
         $rs2[4:0] = $instr[24:20];
         
         
         //INSTRUCTION FIELD DECODE
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         $opcode_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr || $is_b_instr || $is_s_instr;
         ?$opcode_valid
            $opcode[6:0] = $instr[6:0];
         
         //INSTRUCTION DECODE
         $dec_bits [10:0] = {$funct7[5], $funct3, $opcode};
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         
         `BOGUS_USE ($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add)
         
         //REGISTER FILE READ
         $rf_wr_en = 1'b0;
         $rf_wr_index[4:0] = 5'b0;
         $rf_wr_data[31:0] = 32'b0;
         $rf_rd_en1 = $rs1_valid;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_valid;
         $rf_rd_index2[4:0] = $rs2;
         //output of rf
         $src1_value[31:0] = $rf_rd_data1;
         $src2_value[31:0] = $rf_rd_data2;
         
         //ARITHMETIC AND LOGIC UNIT (ALU)
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         32'bx ;
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)

   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule
```
![alu_code](https://github.com/user-attachments/assets/0d35307b-670d-4d30-b4e4-7d023ceeb052)
![alu_dia](https://github.com/user-attachments/assets/c6a81157-5637-4c86-91ee-fcaae2b14c09)

### 6. Reg file write

![image](https://github.com/user-attachments/assets/6ecb21eb-cce0-423c-8118-1ab635d2c29a)

![image](https://github.com/user-attachments/assets/71160228-b82e-4a06-9f41-c49834fb83d7)

```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;
      @1 
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
      ?$imem_rd_en
         @1
            $imem_rd_data[31:0] = /imem[$imem_rd_addr]$instr;  
         
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
         
         
         //INSTRUCTION DECODE
         $rs2[4:0] = $instr[24:20];
         
         
         //INSTRUCTION FIELD DECODE
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         $opcode_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr || $is_b_instr || $is_s_instr;
         ?$opcode_valid
            $opcode[6:0] = $instr[6:0];
         
         //INSTRUCTION DECODE
         $dec_bits [10:0] = {$funct7[5], $funct3, $opcode};
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         
         `BOGUS_USE ($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add)
         
         //REGISTER FILE READ
         $rf_wr_en = 1'b0;
         $rf_wr_index[4:0] = 5'b0;
         $rf_wr_data[31:0] = 32'b0;
         $rf_rd_en1 = $rs1_valid;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_valid;
         $rf_rd_index2[4:0] = $rs2;
         //output of rf
         $src1_value[31:0] = $rf_rd_data1;
         $src2_value[31:0] = $rf_rd_data2;
         
         //ARITHMETIC AND LOGIC UNIT (ALU)
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         32'bx ;
         
         //REGISTER FILE WRITE
         $rf_wr_en = $rd_valid && $rd != 5'b0;
         $rf_wr_index[4:0] = $rd;
         $rf_wr_data[31:0] = $result;
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)

   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule
```
![reg_file_write_code](https://github.com/user-attachments/assets/89fbff16-0d94-494b-91c5-6817b5b184f3)
![reg_file_write_dia](https://github.com/user-attachments/assets/f36b9191-3bc0-4aa3-b8a1-43af271e2baf)

### 7. Branches

![image](https://github.com/user-attachments/assets/29f59904-eca1-42bf-9b67-c31ecbc22da3)

During decode stage, branch target address is calculated and fed into PC mux. Before execute stage, once the operands are ready branch condition is checked. Below is snapshot from Makerchip IDE after including the control logic for branch instructions.<br/>

* The first is without targetting the pc.<br/>

```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;
      @1 
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
      ?$imem_rd_en
         @1
            $imem_rd_data[31:0] = /imem[$imem_rd_addr]$instr;  
         
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
         
         
         //INSTRUCTION DECODE
         $rs2[4:0] = $instr[24:20];
         
         
         //INSTRUCTION FIELD DECODE
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         $opcode_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr || $is_b_instr || $is_s_instr;
         ?$opcode_valid
            $opcode[6:0] = $instr[6:0];
         
         //INSTRUCTION DECODE
         $dec_bits [10:0] = {$funct7[5], $funct3, $opcode};
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         
         `BOGUS_USE ($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add)
         
         //REGISTER FILE READ
         $rf_wr_en = 1'b0;
         $rf_wr_index[4:0] = 5'b0;
         $rf_wr_data[31:0] = 32'b0;
         $rf_rd_en1 = $rs1_valid;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_valid;
         $rf_rd_index2[4:0] = $rs2;
         //output of rf
         $src1_value[31:0] = $rf_rd_data1;
         $src2_value[31:0] = $rf_rd_data2;
         
         //ARITHMETIC AND LOGIC UNIT (ALU)
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         32'bx ;
         
         //REGISTER FILE WRITE
         $rf_wr_en = $rd_valid && $rd != 5'b0;
         $rf_wr_index[4:0] = $rd;
         $rf_wr_data[31:0] = $result;
         
         //BRANCH INSTRUCTIONS
         $taken_branch = $is_beq ? ($src1_value == $src2_value):
                         $is_bne ? ($src1_value != $src2_value):
                         $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])):
                         $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])):
                         $is_bltu ? ($src1_value < $src2_value):
                         $is_bgeu ? ($src1_value >= $src2_value):
                                    1'b0;
         `BOGUS_USE($taken_branch)
         
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)

   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule
```
![branch1_code](https://github.com/user-attachments/assets/49f226b8-e6cc-4961-9955-6bd4d80b0bfc)
![branch1_dia](https://github.com/user-attachments/assets/a594fec6-1a06-4460-8f53-15b254187ed3)

The second is targetting the pc.<br/>

```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $pc[31:0] = >>1$reset ? 32'b0 : >>1$pc + 32'd4;
      @1 
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $imem_rd_en = !$reset;
         $instr[31:0] = $imem_rd_data[31:0];
         
      ?$imem_rd_en
         @1
            $imem_rd_data[31:0] = /imem[$imem_rd_addr]$instr;  
         
         //INSTRUCTION TYPES DECODE         
      @1
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_r_instr = $instr[6:2] ==? 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==? 5'b10100;
         
         $is_j_instr = $instr[6:2] ==? 5'b11011;
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==? 5'b11001;
         
         $is_b_instr = $instr[6:2] ==? 5'b11000;
         
         //INSTRUCTION IMMEDIATE DECODE
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0} :
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                                    32'b0;
         
         
         //INSTRUCTION DECODE
         $rs2[4:0] = $instr[24:20];
         
         
         //INSTRUCTION FIELD DECODE
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
            
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
            
         $funct7_valid = $is_r_instr ;
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
            
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         $opcode_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr || $is_b_instr || $is_s_instr;
         ?$opcode_valid
            $opcode[6:0] = $instr[6:0];
         
         //INSTRUCTION DECODE
         $dec_bits [10:0] = {$funct7[5], $funct3, $opcode};
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         
         `BOGUS_USE ($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add)
         
         //REGISTER FILE READ
         $rf_wr_en = 1'b0;
         $rf_wr_index[4:0] = 5'b0;
         $rf_wr_data[31:0] = 32'b0;
         $rf_rd_en1 = $rs1_valid;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_valid;
         $rf_rd_index2[4:0] = $rs2;
         //output of rf
         $src1_value[31:0] = $rf_rd_data1;
         $src2_value[31:0] = $rf_rd_data2;
         
         //ARITHMETIC AND LOGIC UNIT (ALU)
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         32'bx ;
         
         //REGISTER FILE WRITE
         $rf_wr_en = $rd_valid && $rd != 5'b0;
         $rf_wr_index[4:0] = $rd;
         $rf_wr_data[31:0] = $result;
         
         //BRANCH INSTRUCTIONS1
         $taken_branch = $is_beq ? ($src1_value == $src2_value):
                         $is_bne ? ($src1_value != $src2_value):
                         $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])):
                         $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])):
                         $is_bltu ? ($src1_value < $src2_value):
                         $is_bgeu ? ($src1_value >= $src2_value):
                                    1'b0;
         `BOGUS_USE($taken_branch)
         //BRANCH INSTRUCTIONS 2
         $br_target_pc[31:0] = $pc +$imm;
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)

   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule
```
![branch2_code](https://github.com/user-attachments/assets/68d0f9b2-0714-42d2-a4de-ebd46edcc288)
![branch2_dia](https://github.com/user-attachments/assets/1b49c26c-e79c-4d06-aa54-d363261da89f)


### 8. Testbench

when simulation passes by monitoring the value in register x10
(containing the sum) (within @1):
The output will be the addition of 1 to 9 which is 45 and in hexadecimal 2D.
The clk can be changed by putting ```$clk_chandan = *clk; ```  in day 4 basic risc v implementation. I have not putted that i have put it in the day 5 of pipelined risc v core implementation and also the waveform has been put for day 5 work as it is fully completed work.<br/>
```
*passed = |cpu/xreg[10]>>5$value == (1+2+3+4+5+6+7+8+9);
```
![tb_code](https://github.com/user-attachments/assets/dede61b8-58e4-45de-847f-dd5cf1f8e4f1)
![tb_dia](https://github.com/user-attachments/assets/eb84d7ff-2d7a-4c30-8cb6-fcaa9e9d00a8)

# LAB 7

## Pipelined RISC-V Core

Converting non-piepleined CPU to pipelined CPU using timing abstract feature of TL-Verilog. This allows easy retiming wihtout any risk of funcational bugs. More details reagrding Timing Abstract in TL-Verilog can be found in IEEE Paper ["Timing-Abstract Circuit Design in Transaction-Level Verilog" by Steven Hoover.](https://ieeexplore.ieee.org/document/8119264)<br/>

## Valid Signal

To find valid signals for the program counter to execute and point, introduce a `` $start `` and a new `` $valid `` signal as following:<br/>

```
$start = >>1$reset && !$reset;
$valid = $reset ? 1'b0 : ($start || >>3$valid);

```
Moreover, a new valid branch signal is assigned as follows: 

```
$valid_taken_br = $valid && $taken_branch;
```

The next thing to do is to incorporate this into the program counter assignment as follows from 3 instruction next it gets changes after adding the jump instruction for that code it is followed by previous code: 

```
$pc[31:0] = >>1$reset ? 1'b0 : >>3$valid_taken_branch ? >>3$br_tgt_pc : >>1$pc + 32'd4;
```
```
$pc[31:0] = >>1$reset ? 32'd0 :
                     >>3$valid_taken_br ? >>3$br_tgt_pc :
                     >>3$valid_load ? >>3$inc_pc :
                     >>3$valid_jump && >>3$is_jal ? >>3$br_tgt_pc :
                     >>3$valid_jump && >>3$is_jalr ? >>3$jalr_tgt_pc :
                     >>1$inc_pc;
```
## Branch Target Path 

The `$valid`, `$valid_load` and `$valid_jump` signals need to be defined and incorporated in the `$valid` signal now in `@1`.

```
$valid = !(>>1$valid_taken_branch || >>2$valid_taken_branch || >>1$valid_load || >>2$valid_load 
                    || >>1$valid_jump || >>2$valid_jump) ;
                    
         $valid_load = $valid && $is_load ;
         $valid_jump = $valid && $is_load;
      


```
Moving on, more instruction signals are added to the code. They are: 

```
$is_load = $dec_bits ==? 11'bx_xxx_0000011;
        $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         $is_lui = $dec_bits ==? 11'bx_xxx_0110111;
         $is_auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $is_jal = $dec_bits ==? 11'bx_xxx_1101111;
         $is_jalr = $dec_bits ==? 11'bx_000_1100111;
         $is_load = $dec_bits ==? 11'bx_xxx_0000011;
         $is_sb = $dec_bits ==? 11'bx_000_0100011;
         $is_sh = $dec_bits ==? 11'bx_001_0100011;
         $is_sw = $dec_bits ==? 11'bx_010_0100011;
         $is_slti = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0100011;
         $is_xori = $dec_bits ==? 11'bx_100_0100011;
         $is_ori = $dec_bits ==? 11'bx_110_0100011;
         $is_andi = $dec_bits ==? 11'bx_111_0100011;
         $is_slli = $dec_bits ==? 11'b0_001_0100011;
         $is_srli = $dec_bits ==? 11'b0_101_0100011;
         $is_srai = $dec_bits ==? 11'b1_101_0100011;
         $is_sub = $dec_bits ==? 11'b1_000_0110011;
         $is_sll = $dec_bits ==? 11'b0_001_0110011;
         $is_slt = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu = $dec_bits ==? 11'b0_011_0110011;
         $is_xor = $dec_bits ==? 11'b0_100_0110011;
         $is_srl = $dec_bits ==? 11'b0_101_0110011;
         $is_sra = $dec_bits ==? 11'b1_101_0110011;
         $is_or = $dec_bits ==? 11'b0_110_0110011;
         $is_and = $dec_bits ==? 11'b0_111_0110011;
```

## Updating Register Read 
Register Read is updated as follows: 

```
         $rf_rd_en1 = $rs1_valid;
         $rf_rd_en2 = $rs2_valid;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_index2[4:0] = $rs2;
```
## Data Memory 

```
         $dmem_wr_en = $is_s_instr && $valid;
         $dmem_rd_en = $is_load;
         $dmem_addr[3:0] = $result[5:2];
         $dmem_wr_data[31:0] = $src2_value;

```

## Load Data

```

$ld_data[31:0] = $dmem_rd_data ;

```
## Adding Instruction Signals and their definitions to $result in ALU 

![image](https://github.com/user-attachments/assets/9ca2500a-7d00-4259-9248-26104e8775d6)

```
$result[31:0] = ($is_addi || $is_load || $is_s_instr) ? $src1_value + $imm :
              $is_add ? $src1_value + $src2_value :
              $is_andi ? $src1_value & $imm :
              $is_ori  ? $src1_value | $imm :
              $is_xori ? $src1_value ^ $imm :
              $is_slli ? $src1_value << $imm[5:0] :
              $is_srli ? $src1_value >> $imm[5:0] :
              $is_and ? $src1_value & $src2_value :
              $is_or ? $src1_value | $src2_value :
              $is_xor ? $src1_value ^ $src2_value :
              $is_sub ? $src1_value - $src2_value :
              $is_sll ? $src1_value << $src2_value[4:0] :
              $is_srl ? $src1_value >> $src2_value[4:0] :
              $is_sltu ? $src1_value < $src2_value :
              $is_sltiu ? $src1_value < $imm :
              $is_lui ? {$imm[31:12], 12'b0} :
              $is_auipc ? $pc + $imm : 
              $is_jal ? $pc + 32'd4 :
              $is_jalr ? $pc + 32'd4 :
              $is_srai ? {{32{$src1_value[31]}}, $src1_value} >> $imm[4:0] :
              $is_slt ? ($src1_value[31] == $src2_value[31]) ? $sltu_rslt : {31'b0, $src1_value[31]} :
              $is_slti ? ($src1_value[31] == $imm[31]) ? $sltiu_rslt : {31'b0, $src1_value[31]} :
              $is_sra ? {{32{$src1_value[31]}}, $src1_value} >> $src2_value[4:0] :
              32'bx ;
      @3
         //Register File Write 
         
         $rf_wr_en = $rd_use && $rd != 5'b0 && $valid || >>2$valid_load;
         $rf_wr_index[4:0] = >>2$valid_load ? >>2$rd : $rd;
         $rf_wr_data[31:0] = >>2$valid_load ? >>2$ld_data :  $result;
         
         //Branch Instructions
         
         $taken_branch = $is_beq ? ($src1_value == $src2_value):
                         $is_bne ? ($src1_value != $src2_value):
                         $is_blt ? (($src1_value < $src2_value)^($src1_value[31] != $src2_value[31])):
                         $is_bge ? (($src1_value >= $src2_value)^($src1_value[31] != $src2_value[31])):
                         $is_bltu ? ($src1_value < $src2_value):
                         $is_bgeu ? ($src1_value >= $src2_value):
                                    1'b0;

```
### Note: Change the MACROS again as follows:

```
|cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      m4+dmem(@4)    // Args: (read/write stage)

   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
```

### PIPELINE OF RISC-V 5 STAGES 

![image](https://github.com/user-attachments/assets/221805b6-b3a6-4443-8dee-4a1b0ca1ee38)

The code snippet of complete RISC-V implementation.<br/>

```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   m4_asm(SW, r0, r10, 100)           // Store final result from r10(a0) to memory at address 16 (0x10)
   m4_asm(LW, r15, r0, 100)           // Load in register x7 value from memory, address 16 (0x10)
   
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_chandan = *clk;
         $pc[31:0] = >>1$reset ? 32'd0 :
                     >>3$valid_taken_br ? >>3$br_tgt_pc :
                     >>3$valid_load ? >>3$inc_pc :
                     >>3$valid_jump && >>3$is_jal ? >>3$br_tgt_pc :
                     >>3$valid_jump && >>3$is_jalr ? >>3$jalr_tgt_pc :
                     >>1$inc_pc;
         
         $start = (>>1$reset && $reset == 0) ? 1'b1 : 1'b0;
      
      @1
         $inc_pc[31:0] = $pc + 32'd4;
         
         $imem_rd_en = ! $reset;
         $imem_rd_addr[31:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $instr[31:0] = $imem_rd_data;
         
         $is_u_instr = $instr[6:2] ==? 5'b0x101;
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         $is_r_instr = $instr[6:2] == 5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] == 5'b10100;
         $is_j_instr = $instr[6:2] == 5'b11011;
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] == 5'b11001;
         $is_b_instr = $instr[6:2] == 5'b11000;
         
         $imm[31:0] = $is_i_instr ? { {21{$instr[31]}}, $instr[30:20] } :
                      $is_s_instr ? { {21{$instr[31]}}, $instr[30:25], $instr[11:8], $instr[7] } :
                      $is_b_instr ? { {20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0 } :
                      $is_u_instr ? { $instr[31], $instr[30:20], $instr[19:12], 12'b0 } :
                      $is_j_instr ? { {12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:25], $instr[24:21], 1'b0 } : 32'b0;
         
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         $rs1_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         $funct7_valid = $is_r_instr;
         $funct3_valid = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         $opcode[6:0] = $instr[6:0];
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
         
      @2
         $dec_bits[10:0] = {$funct7[5],$funct3,$opcode};
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         $is_lui = $dec_bits ==? 11'bx_xxx_0110111;
         $is_auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $is_jal = $dec_bits ==? 11'bx_xxx_1101111;
         $is_jalr = $dec_bits ==? 11'bx_000_1100111;
         $is_load = $dec_bits ==? 11'bx_xxx_0000011;
         $is_sb = $dec_bits ==? 11'bx_000_0100011;
         $is_sh = $dec_bits ==? 11'bx_001_0100011;
         $is_sw = $dec_bits ==? 11'bx_010_0100011;
         $is_slti = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0100011;
         $is_xori = $dec_bits ==? 11'bx_100_0100011;
         $is_ori = $dec_bits ==? 11'bx_110_0100011;
         $is_andi = $dec_bits ==? 11'bx_111_0100011;
         $is_slli = $dec_bits ==? 11'b0_001_0100011;
         $is_srli = $dec_bits ==? 11'b0_101_0100011;
         $is_srai = $dec_bits ==? 11'b1_101_0100011;
         $is_sub = $dec_bits ==? 11'b1_000_0110011;
         $is_sll = $dec_bits ==? 11'b0_001_0110011;
         $is_slt = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu = $dec_bits ==? 11'b0_011_0110011;
         $is_xor = $dec_bits ==? 11'b0_100_0110011;
         $is_srl = $dec_bits ==? 11'b0_101_0110011;
         $is_sra = $dec_bits ==? 11'b1_101_0110011;
         $is_or = $dec_bits ==? 11'b0_110_0110011;
         $is_and = $dec_bits ==? 11'b0_111_0110011;
         
         `BOGUS_USE($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add
                    $is_lui $is_auipc $is_jal $is_jalr $is_load $is_sb $is_sh $is_sw $is_slti
                    $is_sltiu $is_xori $is_ori $is_andi $is_slli $is_srli $is_srai $is_sub $is_sll
                    $is_slt $is_sltu $is_xor $is_srl $is_sra $is_or $is_and)
         
         $rf_rd_en1 = $rs1_valid;
         $rf_rd_en2 = $rs2_valid;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_index2[4:0] = $rs2;
         
         $src1_value[31:0] = >>1$rf_wr_en && (>>1$rf_wr_index == $rf_rd_index1) ? >>1$result : $rf_rd_data1;
         $src2_value[31:0] = >>1$rf_wr_en && (>>1$rf_wr_index == $rf_rd_index2) ? >>1$result : $rf_rd_data2;
         
         $br_tgt_pc[31:0] = $pc + $imm;
         $jalr_tgt_pc[31:0] = $src1_value + $imm;
         
      @3
         $is_jump = $is_jal || $is_jalr;
         $sltu_rslt[31:0] = $src1_value < $src2_value;
         $sltiu_rslt[31:0] = $src1_value < $imm;
         $result[31:0] = ($is_addi || $is_load || $is_s_instr) ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         $is_andi ? $src1_value & $imm :
                         $is_ori ? $src1_value | $imm :
                         $is_xori ? $src1_value ^ $imm :
                         $is_slli ? $src1_value << $imm[5:0] :
                         $is_srli ? $src1_value >> $imm[5:0] :
                         $is_and ? $src1_value & $src2_value :
                         $is_or ? $src1_value | $src2_value :
                         $is_xor ? $src1_value ^ $src2_value :
                         $is_sub ? $src1_value - $src2_value :
                         $is_sll ? $src1_value << $src2_value[4:0] :
                         $is_srl ? $src1_value >> $src2_value[4:0] :
                         $is_sltu ? $sltu_rslt :
                         $is_sltiu ? $sltiu_rslt :
                         $is_lui ? {$imm[31:12],12'b0} :
                         $is_auipc ? $pc + $imm :
                         $is_jal ? $pc + 4 :
                         $is_jalr ? $pc + 4 :
                         $is_srai ? { {32{$src1_value[31]}},$src1_value} >> $imm[4:0] :
                         $is_slt ? ($src1_value[31] == $src2_value[31]) ? $sltu_rslt : {31'b0,$src1_value[31]} :
                         $is_slti ? ($src1_value[31] == $imm[31]) ? $sltiu_rslt : {31'b0,$src1_value[31]} :
                         $is_sra ? { {32{$src1_value[31]}},$src1_value} >> $src2_value[4:0] :
                         32'bx;
         
         $taken_br = $is_beq ? ($src1_value == $src2_value) :
                     $is_bne ? ($src1_value != $src2_value) :
                     $is_blt ? (($src1_value < $src2_value)^($src1_value[31] != $src2_value[31])) :
                     $is_bge ? (($src1_value >= $src2_value)^($src1_value[31] != $src2_value[31])) :
                     $is_bltu ? ($src1_value < $src2_value) :
                     $is_bgeu ? ($src1_value >= $src2_value) :
                     1'b0;
         
         $valid = !(>>1$valid_taken_br || >>2$valid_taken_br ||
                    >>1$valid_load || >>2$valid_load ||
                    >>1$valid_jump || >>2$valid_jump);
         
         $rf_wr_en =  ($rd_valid && ($rd != 5'b0) && $valid) || >>2$valid_load;
         $rf_wr_index[4:0] = >>2$valid_load ? >>2$rd : $rd;
         $rf_wr_data[31:0] = >>2$valid_load ? >>2$ld_data : $result;
         
         $valid_taken_br = $valid && $taken_br;
         $valid_load = $valid && $is_load;
         $valid_jump = $valid && $is_jump;
      
      @4
         $dmem_wr_en = $is_s_instr && $valid;
         $dmem_rd_en = $is_load;
         $dmem_addr[3:0] = $result[5:2];
         $dmem_wr_data[31:0] = $src2_value;
         
      @5
         $ld_data[31:0] = $dmem_rd_data;

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   //*passed = *cyc_cnt > 40;
   *passed = |cpu/xreg[17]>>5$value == (1+2+3+4+5+6+7+8+9);
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      m4+dmem(@4)    // Args: (read/write stage)
   
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic
                       // @4 would work for all labs
\SV
   endmodule
```
The implementation of the above code in makerchip ide [Final code.](makerchip.com/sandbox/0R6frhrvn/0DRhxQ)<br/>

![day_5_code](https://github.com/user-attachments/assets/ed3f33db-4ee9-48a5-a16c-06cd078e4ab6)

![image](https://github.com/user-attachments/assets/13ac3ad2-189c-42b9-a86c-8bea1245b406)

The output is available after 60 cycles.<br/>

![day5_viz1](https://github.com/user-attachments/assets/fa41c730-a461-4e3c-83ca-fac1d49c0b9f)

The below waveform shows the clock in my name ``` $clk_chandan```  and the output result.<br/>

![image](https://github.com/user-attachments/assets/9a24dd05-eb70-4033-ae27-616e2dc035bc)

The waveform output shows the addition of 1 to 9 which gives the output as 45, which in hexadecimal is 2D.<br/>

![day5_result](https://github.com/user-attachments/assets/87a9a78e-2b7c-4980-947b-7e8304c110f2)

![image](https://github.com/user-attachments/assets/1d69f73f-fef7-4c9a-a601-e64d8f502ebd)

![image](https://github.com/user-attachments/assets/71d5e761-4805-4392-a8e7-5f81326ab992)

The final diagram of 5 stage implementation of RISC V core. <br/>

![day5_diag](https://github.com/user-attachments/assets/88892464-ac33-449c-8125-314945416650)

### Code Comparison

The SandPiper Compiler generated ~90,000 characters of SystemVerilog from ~25,000 characters of TL-Verilog. Among the ~90,000 characters of SystemVerilog, only ~18,000 is actual logic.
The snippet below shows the code comparison of TL-Verilog and SystemVerilog.<br/>

![day_5_sandpip](https://github.com/user-attachments/assets/357aa45d-aeb2-48e4-a446-46df27dddbcd)
Summary: The complete implementation of sequential calculator has been done and also the pipelining has been implemented on it The complete implementation of riscv has been done and problems of readwrite hazard and branch hazard and load hazard had been addressed. <br/>

# LAB 8
## Conversion of TLV code into Verilog using the Sandpiper-SaaS compiler. After the conversion, perform pre-synthesis simulations with the GTKWave simulator to verify the design.

The RISC-V processor was designed and created by the TL-Verilog language in the Maketchip IDE. Now, we need a way to compile and transform it to the Verilog language for FPGA implementation. The sandpiper-saas compiler was used to do the job. The pre-synthesis simulation was carried out using the GTKWave simulkator.<br/>

Make changes in the tlv code whereever required. Such as including the top module from shivani shah's github, making corrections in case inequalities, removing x in the inputs and giving the full inputs to perform the simulation without any error and also we can comment the cpuviz memory line.<br/>
 
### Steps to be followed are as shown as below :- 
Step 1:<br/>
Install the Required Packages:<br/>
```
sudo apt install make python python3 python3-pip git iverilog gtkwave
cd ~
sudo apt-get install python3-venv
python3 -m venv .venv
source ~/.venv/bin/activate
pip3 install pyyaml click sandpiper-saas
```
Step 2:<br/>
Now we can clone this repository in an arbitrary directory (we'll choose home directory here):<br/>
```
git clone https://github.com/manili/VSDBabySoC.git
```
Step 3:<br/>
Replace the .tlv file in the VSDBabySoC/src/module folder with our RISC-V design .tlv file which we want to convert into verilog and we can give our own name too.<br/>
```
cd /home/vsduser/VSDBabySoC/
sandpiper-saas -i ./src/module/riscv_chandan.tlv -o riscv_chandan.v --bestsv --noline -p verilog --outdir ./src/module/
```
Step 4:<br/>
Compile and simulate RISC-V design.<br/>
Before executing the below command first create the directory named 'output' so that the pre synthesis file can be putted their.<br/>
```
mkdir output
iverilog -o output/pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module
```
Step 5:<br/>
The result of the simulation (i.e. pre_synth_sim.vcd) will be stored in the output/pre_synth_sim directory.<br/>
```
cd output
./pre_synth_sim.out
```
Step 6:<br/>
To open the .vcd simulation file through GTKWave simulation tool.<br/>
```
gtkwave pre_synth_sim.vcd
```
![terminal](https://github.com/user-attachments/assets/c9439e59-9f30-4206-a497-a3491421b513)
![terminal1](https://github.com/user-attachments/assets/beaa49c6-b306-44d6-948f-b82cf20dd9e3)
![terminal2](https://github.com/user-attachments/assets/3e5684ff-fa59-4dc3-9fad-0fe9a7c24486)

### The Testbench used is shown as below

![testbench](https://github.com/user-attachments/assets/b23e89e2-66be-4b42-a716-aadc003504ee)
```
`timescale 1ns / 1ps
`ifdef PRE_SYNTH_SIM
  
   `include "riscv_chandan.v"
   `include "clk_gate.v"

`endif

module tb;
 wire [9:0] OUT;
reg CLK;
reg reset; 

   riscv_chandan uut (
      .OUT(OUT),.CLK(CLK),
      .reset(reset));
     
always #5 CLK=~CLK;
   initial begin
     CLK=0;
      #20 reset = 1;
      #100 reset = 0;
   end
   
   initial begin
`ifdef PRE_SYNTH_SIM
      $dumpfile("pre_synth_sim.vcd");

`endif
      $dumpvars(0, tb);
   end
 
   initial begin
      
  #20000;
      $finish;
   end
   
endmodule
```
The following diagram contains:-<br/>

CPU_clk_chandan: This is the clock input to the RISC-V core.<br/>
reset: This is the input reset signal to the RISC-V core.<br/>
OUT[9:0]: This is the 10-bit output [9:0] OUT port of the RISC-V core.<br/>

In the below shown waveform the output for me it is getting like once it is reached the final value which is 2D then afterwards it is again starting from 0 and counts untill 2D.<br/>

![waveform](https://github.com/user-attachments/assets/c06aff2f-02e5-4c42-b467-24e49bd6f087)
![waveform1](https://github.com/user-attachments/assets/4da47309-9d09-4a93-86b4-11f71626b242)
![waveform2](https://github.com/user-attachments/assets/8dde47c0-58b3-4ccb-bad0-ee6cff296f0c)
![waveform3](https://github.com/user-attachments/assets/4f0e543d-08a1-4dcf-938d-ed615434f6d5)

Makerchip IDE simulation results for comparison


![image](https://github.com/user-attachments/assets/9a24dd05-eb70-4033-ae27-616e2dc035bc)

![day5_result](https://github.com/user-attachments/assets/87a9a78e-2b7c-4980-947b-7e8304c110f2)

![image](https://github.com/user-attachments/assets/1d69f73f-fef7-4c9a-a601-e64d8f502ebd)

![image](https://github.com/user-attachments/assets/71d5e761-4805-4392-a8e7-5f81326ab992)

By comparing both the simulations the cyc_cnt is seen in the CPU_result_a3[31:0] and the result is seen in the OUT[9:0].<br/>

# LAB 9
## TASK 1
### Installing iverilog, gtkwave, yosys, OpenSTA  in our personal machines.<br/>

 The following are the steps to install the tools which is used for simulation.<br/>
 
  * Iverilog<br/>
  Steps to install iverilog <br/>
  ```
    sudo apt-get update
    sudo apt-get install iverilog
  ```
![gth](https://github.com/user-attachments/assets/b1a1b350-9cf1-44d0-a3b2-ebde2ae722af)

![iverilog](https://github.com/user-attachments/assets/87079bc8-0e3f-4196-b8c6-f5e10f57d31e)

* Gtkwave<br/>
Steps to install gtkwave<br/>
```
sudo apt-get update
sudo apt install gtkwave
```
![7](https://github.com/user-attachments/assets/8a6b2e75-31f4-453f-8c78-750d4493d856)

![image](https://github.com/user-attachments/assets/34a4443f-1e32-4a92-a28a-5c624c796475)

* Yosys<br/>
Steps to install yosys<br/>
```
sudo apt-get update
 git clone https://github.com/YosysHQ/yosys.git
 cd yosys
 sudo apt install make (If make is not installed please install it) 
 sudo apt-get install build-essential clang bison flex \
    libreadline-dev gawk tcl-dev libffi-dev git \
    graphviz xdot pkg-config python3 libboost-system-dev \
    libboost-python-dev libboost-filesystem-dev zlib1g-dev
 make config-gcc
 make 
 sudo make install
```
![2](https://github.com/user-attachments/assets/09ff1666-8b6b-4741-98e1-6596b69aefa6)
![4](https://github.com/user-attachments/assets/140c2e1f-8de2-4890-9191-471a9e3a9dff)
![5](https://github.com/user-attachments/assets/3da8edbb-66f7-4f14-9c2b-9b5869471070)
![6](https://github.com/user-attachments/assets/37fdde42-bfb4-4142-aa9d-d52b0f69a3e7)
![8](https://github.com/user-attachments/assets/68ee80c6-6bb3-450e-b1e6-c428b50b12ca)

* OpenSTA <br/>
Steps to install opensta<br/>
```
git clone https://github.com/parallaxsw/OpenSTA.git
cd OpenSTA
mkdir build
cd build
sudo apt-get install cmake clang gcctcl swig bison flex
cmake ..
make
```
![13](https://github.com/user-attachments/assets/9fb5171d-353f-4bce-ad58-4cc9ad94c9ce)
![image](https://github.com/user-attachments/assets/d4e51373-2894-42cb-a7e3-58e8bf304e74)

## TASK 2
#### Downloading the files from https://github.com/Subhasis-Sahu/BabySoC_Simulation/ link and editing the vsdbabysoc top level so that it links to my rvmyth code and produce the output for that.<br/>

# Introduction to the VSDBabySoC

VSDBabySoC is a small yet powerful RISCV-based SoC. The main purpose of designing such a small SoC is to test three open-source IP cores together for the first time and calibrate the analog part of it. VSDBabySoC contains one RVMYTH microprocessor, an 8x-PLL to generate a stable clock, and a 10-bit DAC to communicate with other analog devices.

![babysoc](https://github.com/user-attachments/assets/f4f7b91f-9d7c-4dbe-bb2c-77bc2d964d50)

## Problem statement

This work discusses the different aspects of designing a small SoC based on RVMYTH (a RISCV-based processor). This SoC will leverage a PLL as its clock generator and controller and a 10-bit DAC as a way to talk to the outside world. Other electrical devices with proper analog input like televisions, and mobile phones could manipulate DAC output and provide users with music sound or video frames. At the end of the day, it is possible to use this small fully open-source and well-documented SoC which has been fabricated under Sky130 technology, for educational purposes.

## What is SoC

An SoC is a single-die chip that has some different IP cores on it. These IPs could vary from microprocessors (completely digital) to 5G broadband modems (completely analog).

## What is RVMYTH

RVMYTH core is a simple RISCV-based CPU, introduced in a workshop by RedwoodEDA and VSD. During a 5-day workshop students (including middle-schoolers) managed to create a processor from scratch. The workshop used the TLV for faster development. All of the present and future contributions to the IP will be done by students and under open-source licenses.

## What is PLL

A phase-locked loop or PLL is a control system that generates an output signal whose phase is related to the phase of an input signal. PLLs are widely used for synchronization purposes, including clock generation and distribution.

## What is DAC

A digital-to-analog converter or DAC is a system that converts a digital signal into an analog signal. DACs are widely used in modern communication systems enabling the generation of digitally-defined transmission signals. As a result, high-speed DACs are used for mobile communications and ultra-high-speed DACs are employed in optical communications systems.

# VSDBabySoC Modeling

Here we are going to model and simulate the VSDBabySoC using `iverilog`, then we will show the results using `gtkwave` tool. Some initial input signals will be fed into `vsdbabysoc` module that make the pll start generating the proper `CLK` for the circuit. The clock signal will make the `rvmyth` to execute instructions in its `imem`. As a result the register `r17` will be filled with some values cycle by cycle. These values are used by dac core to provide the final output signal named `OUT`. So we have 3 main elements (IP cores) and a wrapper as an SoC and of-course there would be also a testbench module out there.

Please note that in the following sections we will mention some repos that we used to model the SoC. However the main source code is resided in [Source-Code Directory](src) and these modules are in [Modules Sub-Directory](src/module).

## RVMYTH modeling

As we mentioned in [What is RVMYTH](#what-is-rvmyth) section, RVMYTH is designed and created by the TL-Verilog language. So we need a way for compile and trasform it to the Verilog language and use the result in our SoC. Here the `sandpiper-saas` could help us do the job.

  [Here](https://github.com/shivanishah269/risc-v-core) is the repo we used as a reference to model the RVMYTH

## PLL and DAC modeling

It is not possible to sythesis an analog design with Verilog, yet. But there is a chance to simulate it using `real` datatype. We will use the following repositories to model the PLL and DAC cores:

  1. [Here](https://github.com/vsdip/rvmyth_avsdpll_interface) is the repo we used as a reference to model the PLL
  2. [Here](https://github.com/vsdip/rvmyth_avsddac_interface) is the repo we used as a reference to model the DAC

**CAUTION:** In the beginning of the project, we get our verilog model of the PLL from [here](https://github.com/vsdip/rvmyth_avsdpll_interface). However, by proceeding the project to the physical design flow we realize that this model needs a little changes to become sufficient for a real IP core. So we changed it a little and created a new model named `AVSDPLL` based on [this](https://github.com/lakshmi-sathi/avsdpll_1v8) IP

Before editing the code i checked the same code for seeing the working of tools installed previously.<br/>
And i got the same output as the https://github.com/manili/VSDBabySoC?tab=readme-ov-file#step-by-step-modeling-walkthrough link and verified that the tool is working.<br/>

As mentioned in the previous lab task the same procedure to be followed for compiling the code and getting the output.<br/>
```
sudo apt install make python python3 python3-pip git iverilog gtkwave
cd ~
sudo apt-get install python3-venv
python3 -m venv .venv
source ~/.venv/bin/activate
pip3 install pyyaml click sandpiper-saas

git clone https://github.com/manili/VSDBabySoC.git

cd /home/iiitb/VSDBabySoC/
sandpiper-saas -i ./src/module/*.tlv -o rvmyth.v --bestsv --noline -p verilog --outdir ./src/module/

mkdir output
iverilog -o output/pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module

cd output
./pre_synth_sim.out

gtkwave pre_synth_sim.vcd

```

![17](https://github.com/user-attachments/assets/99bf5c50-f42d-4bfc-9d0d-bedc9e7b54d3)

![14_vsdbabysoc_waveform](https://github.com/user-attachments/assets/dde11842-6283-4068-8435-684abe74ab0f)

Now, i changed vsdbabysoc top level and added my .v generated file from my.tlv file and in extra added the clk in my name and included the files of .v .<br/>
After editing, the same steps are to be followed to see the output in the gtkwave by changing the file name.<br/>
```
sudo apt install make python python3 python3-pip git iverilog gtkwave
cd ~
sudo apt-get install python3-venv
python3 -m venv .venv
source ~/.venv/bin/activate
pip3 install pyyaml click sandpiper-saas

git clone https://github.com/manili/VSDBabySoC.git

cd /home/iiitb/VSDBabySoC/
sandpiper-saas -i ./src/module/*.tlv -o riscv_chandan.v --bestsv --noline -p verilog --outdir ./src/module/

mkdir output
iverilog -o output/pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module

cd output
./pre_synth_sim.out

gtkwave pre_synth_sim.vcd
```

![15](https://github.com/user-attachments/assets/4c05edfb-1fb9-4997-8d61-0e5c7dc2e536)
![16](https://github.com/user-attachments/assets/3e907c4b-4359-481d-a8d5-c9661127cb87)
![22](https://github.com/user-attachments/assets/d017472d-384a-40d5-b382-d1a168ecb6df)

The things changed in testbench and vsdbabysoc file is shown below:- <br/>
![25](https://github.com/user-attachments/assets/db5d55e6-bf71-46de-8cc1-f0e1ee8a73ec)
![24](https://github.com/user-attachments/assets/8f9ae3ef-a060-4625-91ee-0b454bf2c148)

After the above steps are completed the output will be is as shown below waveform it consists of pll input and output signal and dac's output signal and also the clock in my name and reset signal.<br/>

![pll](https://github.com/user-attachments/assets/7f55cc9e-e20d-4bfb-b181-02b07466347e)


![20](https://github.com/user-attachments/assets/1d7edf3f-b218-4613-be40-2056a8e76358)

Zoomed view
![21](https://github.com/user-attachments/assets/0db20891-d85d-4f0c-ab00-d0b0612857d0)

For verifying that i have done in my own machine is that my name in the terminal is "MS2024007@ckns7" please do check it.

Summary :- In this task the output seen is PLL clock input signal, PLL output signal, your individual clock (rvmyth input clock signal), rvmyth 10-bit output signals, DAC output analog waveform.

# LAB 10
## TASK 1
### Installing the tools which are not installed in previous lab 
### NGSPICE
The following are the commands for installing the ngspice:<br/>
```
wget https://sourceforge.net/projects/ngspice/files/ngspice-43.tar.gz
tar -zxvf ngspice-43.tar.gz
cd ngspice-43
mkdir release
cd release
../configure  --with-x --with-readline=yes --disable-debug
make
sudo make install
```
![ngspice](https://github.com/user-attachments/assets/85ec9fae-084f-4082-9113-6a9ba0fe85aa)

### MAGIC 
The following are the commands to install the magic tool:<br/>
```
sudo apt-get install m4
sudo apt-get install tcsh
sudo apt-get install csh
sudo apt-get install libx11-dev
sudo apt-get install tcl-dev tk-dev
sudo apt-get install libcairo2-dev
sudo apt-get install mesa-common-dev libglu1-mesa-dev
sudo apt-get install libncurses-dev
git clone https://github.com/RTimothyEdwards/magic
cd magic
./configure
make
make install
```
![magic](https://github.com/user-attachments/assets/8e8fca21-4076-48da-8ed7-1bd051690c77)

### OPENLANE
The followiing are the steps to install openlane:<br/>
```
sudo apt-get update
sudo apt-get upgrade
sudo apt install -y build-essential python3 python3-venv python3-pip make git

# Docker Installation : 
sudo apt install apt-transport-https ca-certificates curl software-properties-common
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

sudo apt update

sudo apt install docker-ce docker-ce-cli containerd.io

sudo docker run hello-world

sudo groupadd docker
sudo usermod -aG docker $USER
sudo reboot 

# After reboot
docker run hello-world
```
### Steps to install OpenLane, PDKs and Tools
```
cd $HOME
git clone https://github.com/The-OpenROAD-Project/OpenLane
cd OpenLane
make
make test
```
### TASK 2
### DAY 1 : Introduction to Verilog RTL Design and Synthesis
#### Overview
This session is about steps followed to compile and simulate verilog design and testbench codes using iverilog tool. This section also deals with graphical waveform viewer tool called gtkwave and synthesis tool called yosys and its steps to produce netlist from design file.<br/>

Sample Verilog simulation<br/>
This session takes an example of 2x1 multiplexer (verilog design and test bench) to demonstrate iverilog compilation and gtkwave waveform viewer.<br/>

The verilog codes are taken from github repository:
https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git<br/>

Following is syntax for compilation and execution of verilog codes to generation outputs.<br/>
```
iverilog designfile.v testbench.v
./aout
gtkwave vcdfile.vcd
```
Below represents sample design verilog codes.<br/>
To get through these files just type the below commands in terminal:<br/>
```
cd home/ms2024007/PD/sky130RTLDesignAndSynthesisWorkshop/verilog_files/
ls
```
![verilog_files](https://github.com/user-attachments/assets/05d5a200-62ee-4069-85ff-ff867827a85e)
![verilog_files_1](https://github.com/user-attachments/assets/3c1a8d9f-2bc2-432e-9d46-5748a0bd56fe)

### Standard cell library :- 
It is a collection of well defined and appropriately characterized logic gates that can be used to implement a digital design. Timing data of standard cells is provided in the Liberty format.<br/>

The lib directory contains the library file sky130_fd_sc_hd__tt_025C_1v80.lib. Libraries in the SKY130 PDK are named using the following scheme:<br/>
<Process_name><Library_Source_Abbreviation><Library_type_abbreviation>[_<Library_name]<br/>

sky130 - Process Technology of the PDK sky130<br/>
fd - SkyWater Foundry<br/>
sc - Digital standard cells<br/>
hd - High density<br/>
tt - Typical Timing<br/>
025C - 25 degree celsius Temperature<br/>
1v80 - 1.8V Supply Voltage<br/>

### Demostration of the Icarus Verilog and GTKWave
Change the current working directory to the directory containing the Verilog files using the following command :<br/>
```
cd home/ms2024007/PD/sky130RTLDesignAndSynthesisWorkshop/verilog_files/
```
Simulate the RTL design and testbench using the following command:
```
iverilog good_mux.v tb_good_mux.v 
./a.out
gtkwave tb_good_mux.vcd
```
The code for 2 x 1 mux is:-<br/>
```
module good_mux (input i0 , input i1 , input sel , output reg y);
always @ (*)
begin
	if(sel)
		y <= i1;
	else 
		y <= i0;
end
endmodule
```
Testbench :-<br/>
```
`timescale 1ns / 1ps
module tb_good_mux;
	// Inputs
	reg i0,i1,sel;
	// Outputs
	wire y;

        // Instantiate the Unit Under Test (UUT)
	good_mux uut (
		.sel(sel),
		.i0(i0),
		.i1(i1),
		.y(y)
	);

	initial begin
	$dumpfile("tb_good_mux.vcd");
	$dumpvars(0,tb_good_mux);
	// Initialize Inputs
	sel = 0;
	i0 = 0;
	i1 = 0;
	#300 $finish;
	end

always #75 sel = ~sel;
always #10 i0 = ~i0;
always #55 i1 = ~i1;
endmodule
```
![gtkwave](https://github.com/user-attachments/assets/57d94c3d-aaca-44f5-a596-6da2b7fa2b31)

Waveform :-<br/>

![gtk_wave_2_1_mux](https://github.com/user-attachments/assets/75155189-4293-491d-929a-6de14a4ac5ca)

### Yosys synthesis process
This section explains the concept of yosys library cells and process of generating netlist using yosys tool. The library contains variety of cells with various operating speeds for different applications and avoid violations.<br/>
Following represents various commands used to generate netlist for given design:-<br/>
```
yosys> read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
yosys> read_verilog good_mux.v
yosys> synth -top good_mux
yosys> abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
yosys> show
yosys> write_verilog good_mux_netlist.v
yosys> write_verilog -noattr good_mux_netlist.v
```
The general way is:-
```
yosys> read_liberty -lib <path to lib file>
yosys> read_verilog <path to verilog file>
yosys> synth -top <top_module_name>
yosys> abc -liberty <path to lib file>
yosys> show
yosys> write_verilog <file_name_netlist.v>
yosys> write_verilog -noattr <file_name_netlist.v>
```
Below represents schematic represented by yosys tool for given design:-<br/>
![mux_synth_dia](https://github.com/user-attachments/assets/e4240551-72da-44e2-b293-9c45ff4f73d9)

Below represents netlist represented by yosys tool for given design.<br/>
```
/* Generated by Yosys 0.45+3 (git sha1 d56716417, g++ 11.4.0-1ubuntu1~22.04 -fPIC -O3) */

module good_mux(i0, i1, sel, y);
  wire _0_;
  wire _1_;
  wire _2_;
  wire _3_;
  input i0;
  wire i0;
  input i1;
  wire i1;
  input sel;
  wire sel;
  output y;
  wire y;
  sky130_fd_sc_hd__mux2_1 _4_ (
    .A0(_0_),
    .A1(_1_),
    .S(_2_),
    .X(_3_)
  );
  assign _0_ = i0;
  assign _1_ = i1;
  assign _2_ = sel;
  assign y = _3_;
endmodule
```
![mux_netlist](https://github.com/user-attachments/assets/5f0d8607-308e-4929-933d-432d67cf45c5)

### DAY 2 :- Timing libs, Hierarchical vs Flat Synthesis and Efficient flop coding styles 
Exploring the Contents of .lib File<br/>
To view the contents inside the .lib file type the following command :<br/>
```
cd home/ms2024007/PD/sky130RTLDesignAndSynthesisWorkshop/lib/
gedit sky130_fd_sc_hd__tt_025C_1v80.lib
```

![Screenshot from 2024-10-21 14-49-24](https://github.com/user-attachments/assets/0cce845d-155e-42c9-90ec-57c27a3e0e53)

One of the fundamental parameter stored within .lib files comprises PVT parameters, where P signifies Process, V represents Voltage, and T denotes Temperature. 
The variations in these parameters can cause significant changes in the performance of circuits.<br/>

1. Process Variation: During the manufacturing process, there may be some deviations in the transistor characteristics, causing non-uniformity across the semiconductor wafer. Critical parameters like oxide thickness, dopant concentration, and transistor dimensions experience alterations.<br/>

2. Voltage Variation: Voltage regulators might exhibit variability in their output voltage over time, inducing fluctuations in current and impacting the operational speed of circuits. <br/>

3. Temperature Variation: The functionality of a semiconductor device is sensitive to changes in temperature, particularly at the internal junctions of the chip. <br/>

Further it contains the technology that is used is CMOS for which delay are modelled  through table lookup. This file also defines the units for parameters like voltage, power, current, capacitance, and resistance. Within the .lib library, each standard cell consists a  set of parameters specific to that cell's features.<br/>

### **Hiererchical Synthesis and Flat Synthesis**
Hierarchical synthesis is breaking a comples modules into smaller, more manageable sub-modules or blocks. Each of these sub-modules can be synthesized or designed independently before being integrated into the larger system. This approach allows for efficient design, optimization, and verification of individual components while maintaining a structured and organized design process. An illustration of the hierarchical synthesis is shown below :<br/>

Consider the verilog file multiple module which is given in the verilog_files directory<br/>

 ```
module sub_module2 (input a, input b, output y);
	assign y = a | b;
endmodule

module sub_module1 (input a, input b, output y);
	assign y = a&b;
endmodule


module multiple_modules (input a, input b, input c , output y);
	wire net1;
	sub_module1 u1(.a(a),.b(b),.y(net1));  //net1 = a&b
	sub_module2 u2(.a(net1),.b(c),.y(y));  //y = net1|c ,ie y = a&b + c;
endmodule
 ```
In this case the module multiple_modules iinstantiates two sub_modules where the sub_module1 implements the AND gate and sub_module2 implemets the OR gate which are integrated in the multiple_modules. Synthesis the multiple module using the sollowing commands:<br/>
```
cd /home/ms2024007/PD/sky130RTLDesignAndSynthesisWorkshop/verilog_files/
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog 
read_verilog multiple_modules.v 
synth -top multiple_modules
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show multiple_modules
write_verilog multiple_modules_netlist.v
```
#### **Note:**</br>
 When using hierarchical design instead of enetering the ***show*** command to view the file ***show <module_name>*** must be otherwise yosys will generate the following error : "ERROR: For formats different than 'ps' or 'dot' only one module must be selected."<br/>
 
 Following represents schematic netlist of hierarchy design.<br/>
 ![multiple_modules_show](https://github.com/user-attachments/assets/cfc44213-4dcd-42b1-9d30-24e20ba9087a)

 Netlist generated at first:-
![m_m_net_dia](https://github.com/user-attachments/assets/a691ef35-d99b-45a2-a966-7f4d8e108786)
![m_m_net_dia1](https://github.com/user-attachments/assets/d59153fa-2df1-4042-b156-04b9d5fe639d)
```
/* Generated by Yosys 0.45+3 (git sha1 d56716417, g++ 11.4.0-1ubuntu1~22.04 -fPIC -O3) */

module multiple_modules(a, b, c, y);
  input a;
  wire a;
  input b;
  wire b;
  input c;
  wire c;
  wire net1;
  output y;
  wire y;
  sub_module1 u1 (
    .a(a),
    .b(b),
    .y(net1)
  );
  sub_module2 u2 (
    .a(net1),
    .b(c),
    .y(y)
  );
endmodule

module sub_module1(a, b, y);
  wire _0_;
  wire _1_;
  wire _2_;
  input a;
  wire a;
  input b;
  wire b;
  output y;
  wire y;
  sky130_fd_sc_hd__and2_0 _3_ (
    .A(_1_),
    .B(_0_),
    .X(_2_)
  );
  assign _1_ = b;
  assign _0_ = a;
  assign y = _2_;
endmodule

module sub_module2(a, b, y);
  wire _0_;
  wire _1_;
  wire _2_;
  input a;
  wire a;
  input b;
  wire b;
  output y;
  wire y;
  sky130_fd_sc_hd__or2_0 _3_ (
    .A(_1_),
    .B(_0_),
    .X(_2_)
  );
  assign _1_ = b;
  assign _0_ = a;
  assign y = _2_;
endmodule
```
For getting the flatten design below are the commands :-<br/>
```
cd /home/ms2024007/PD/sky130RTLDesignAndSynthesisWorkshop/verilog_files/
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog 
read_verilog multiple_modules.v 
synth -top multiple_modules
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
flatten
show 
write_verilog multiple_modules_flatten_netlist.v
```

Following represents schematic netlist of flat design.<br/>

![m_m_net_flatten_dia](https://github.com/user-attachments/assets/a3cd7b17-014b-44a4-a9e7-4c3767cae9ee)

The below represents the netlist file.<br/>
```
/* Generated by Yosys 0.45+3 (git sha1 d56716417, g++ 11.4.0-1ubuntu1~22.04 -fPIC -O3) */

module multiple_modules(a, b, c, y);
  wire _0_;
  wire _1_;
  wire _2_;
  wire _3_;
  wire _4_;
  wire _5_;
  input a;
  wire a;
  input b;
  wire b;
  input c;
  wire c;
  wire net1;
  wire \u1.a ;
  wire \u1.b ;
  wire \u1.y ;
  wire \u2.a ;
  wire \u2.b ;
  wire \u2.y ;
  output y;
  wire y;
  sky130_fd_sc_hd__and2_0 _6_ (
    .A(_1_),
    .B(_0_),
    .X(_2_)
  );
  sky130_fd_sc_hd__or2_0 _7_ (
    .A(_4_),
    .B(_3_),
    .X(_5_)
  );
  assign _4_ = \u2.b ;
  assign _3_ = \u2.a ;
  assign \u2.y  = _5_;
  assign \u2.a  = net1;
  assign \u2.b  = c;
  assign y = \u2.y ;
  assign _1_ = \u1.b ;
  assign _0_ = \u1.a ;
  assign \u1.y  = _2_;
  assign \u1.a  = a;
  assign \u1.b  = b;
  assign net1 = \u1.y ;
endmodule
```
The flatten command breaks the hierarchy and makes the design into a single module by creating AND and OR gates for the logics inferred by the submodule which is shown in the images above. <br/>

### Synthesising a Submodule :
In this section, we learn about synthesis process of submodules and generating corrspnding netlist.<br/>

We follow the similar steps as decribed previously with small change in synthesis command i.e we specify the subodule name we are interested and apply steps similar to we have seen previosuly till netlist generation.<br/>

```
cd /home/ms2024007/PD/sky130RTLDesignAndSynthesisWorkshop/verilog_files/
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog multiple_modules.v 
synth -top sub_module1
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show sub_module1
```

![sub_module1_dia](https://github.com/user-attachments/assets/44223285-5078-4cc5-aab4-dea8b06c3ad8)

For synthesizing the sub module 2<br/>
```
cd /home/ms2024007/PD/sky130RTLDesignAndSynthesisWorkshop/verilog_files/
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog multiple_modules.v 
synth -top sub_module2
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show sub_module2
```
![Screenshot from 2024-10-21 15-21-08](https://github.com/user-attachments/assets/9eefed32-519e-452d-83c8-0c2bb529d690)

We prefer to synthesize submodules separately due to various reasons such as inefficient synthesis carried out if done with entire module, if design contains replica of sub modules, we would like to synthesize once and combine together in main module.<br/>

### Coding styles
This section explains about various coding styles.<br/>

Usually, in a digital circuit, we encounter an issue called as glitch. This is due to propagation delay associated with gates in circuit. To resolve this issue, we use D flip flop in between combinational circuits to hold the stable value and prevent it from disturbing next stage until positive edge of clock occurs. Hence, we want a particular value to occur initially. This is achieved through synchronous or asynchronous reset signals.<br/>

**Steps to simulate and generate the netlist for the below designs**

Simulation steps :
```
iverilog <rtl_name.v> <tb_name.v>
./a.out
gtkwave <dump_file_name.vcd>
```

Generating netlist steps :
```
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib  
read_verilog <module_name.v> 
synth -top <top_module_name>
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
write_verilog -noattr <netlist_name.v>
```

***Note***:</br>
**dfflibmap** - technology mapping of flip-flops</br>
dfflibmap  -liberty - Maps internal flip-flop cells to the flip-flop cells in the technology library specified in the given liberty file.<br/>

Generally in the flow there will be a separate .lib file for the flip-flops which needs to be used with the dfflibmap command.<br/>

### **Illustration of Different types of Flip-flop** 
**1. D flip-flop with Synchronous reset**</br>

A D flip-flop with synchronous reset  combines the functionality of a D flip-flop with the ability to reset its state synchronously. This means that the flip-flop's stored value can be reset to 0 or low state based on a clock signal and a reset input, ensuring that the reset operation occurs when the clock signal transits.
The verilog code, simulation and synthesis results are shown below:<br/>

```
module dff_syncres ( input clk , input async_reset , input sync_reset , input d , output reg q );
always @ (posedge clk )
begin
	if (sync_reset)
		q <= 1'b0;
	else	
		q <= d;
end
endmodule
```
![dff_sync_res_wave](https://github.com/user-attachments/assets/0346230e-49ee-4784-b9cf-f6047ee7d5cf)
![dff_sync_reset_net_dia](https://github.com/user-attachments/assets/0195dc76-0e18-4592-9327-06cb8defc215)

**2. D flip-flop with Asynchronous reset**</br>

A D flip-flop with asynchronous reset combines the functionality of a D flip-flop with the ability to reset its state asynchronously. This means that the flip-flop's stored value can be reset to 0 or low state regardless of the clock signal's state.
The verilog code, simulation and synthesis results are shown below:
```
module dff_asyncres ( input clk ,  input async_reset , input d , output reg q );
always @ (posedge clk , posedge async_reset)
begin
	if(async_reset)
		q <= 1'b0;
	else	
		q <= d;
end
endmodule
```
![dff_asyn_res_wave](https://github.com/user-attachments/assets/4c917844-25ee-41f7-a9b2-3a54a65ce778)
![dff_asyn_reset_netlist_dia](https://github.com/user-attachments/assets/c8398136-0ba0-4122-801f-1a63ae8b6eca)

**3. D flip-flop with Asynchronous set**</br>

A D flip-flop with asynchronous set combines the functionality of a D flip-flop with the ability to set its state asynchronously. This means that the flip-flop's stored value can be set to 1 or high state regardless of the clock signal's state.
The verilog code, simulation and synthesis results are shown below:

```
module dff_async_set ( input clk ,  input async_set , input d , output reg q );
always @ (posedge clk , posedge async_set)
begin
	if(async_set)
		q <= 1'b1;
	else	
		q <= d;
end
endmodule
```
![dff_asyn_se_wave](https://github.com/user-attachments/assets/4a832484-1ecc-4714-b77e-8fefd1ae552c)
![dff_sync_set_netlist_dia](https://github.com/user-attachments/assets/ea60b3ce-a9f3-46a9-b6e6-248421ae4d81)

**4. D flip-flop with Asynchronous and Synchronous reset**</br>

A D flip-flop with both asynchronous and synchronous reset that combines the features of a D flip-flop with the ability to reset its state using either an asynchronous reset input or a synchronous reset input. This provides flexibility in resetting the flip-flop's state under different conditions.

The verilog code, simulation and synthesis results are shown below:

```
module dff_asyncres_syncres ( input clk , input async_reset , input sync_reset , input d , output reg q );
always @ (posedge clk , posedge async_reset)
begin
	if(async_reset)
		q <= 1'b0;
	else if (sync_reset)
		q <= 1'b0;
	else	
		q <= d;
end
endmodule
```
![Screenshot from 2024-10-21 15-43-28](https://github.com/user-attachments/assets/09cff831-b2ae-41a6-9de3-f14ac3dda5ed)
![Screenshot from 2024-10-21 15-47-33](https://github.com/user-attachments/assets/43849f21-22cb-4cfb-afe9-de0c90a01423)

### **Optimizations**
During synthesis yosys will perform optimisations based on the logic that is being designed. An illustration of the yosys optimization is given below:

**1. Optimisation Example 1**

Consider the verilog design given below:
```
module mul2 (input [2:0] a, output [3:0] y);
	assign y = a * 2;
endmodule
```
This code performs multiplication of the input number by 2. Since the input is 3-bit binary number all the input and output combinations are as follows:
| a2 a1 a0  |y3 y2 y1 y0   |
|:---:|:---:|
| 0 0 0 | 0 0 0 0  |
| 0 0 1 | 0 0 1 0  |
| 0 1 0 | 0 1 0 0  |
| 0 1 1 | 0 1 1 0  |
| 1 0 0 | 1 0 0 0  |
| 1 0 1 | 1 0 1 0  |
| 1 1 0 | 1 1 0 0  |
| 1 1 1 | 1 1 1 0  |

y0 is always 0 and the code doesn't need any hardware and it only needs the proper wiring of the input bits to the output and grounding the bit y0. The netlist of the design is shown below:<br/>

![mul_2_netlist_dia](https://github.com/user-attachments/assets/42615039-13e3-414f-82c7-59ef9f594172)
![Screenshot from 2024-10-21 15-49-38](https://github.com/user-attachments/assets/557177a0-a39d-4fbe-b522-710951a378c4)

**2. Optimisation Example 2**

Consider the verilog design given below:
```
module mult8 (input [2:0] a , output [5:0] y);
	assign y = a * 9;
endmodule
```
In this design the 3-bit input number "a" is multiplied by 9 i.e.,(a*9) which can be re-written as (a\*8) + a . The term (a\*8) is nothing but a left shifting the number a by three bits. Consider that a = a2 a1 a0. (a\*8) results in a2 a1 a0 0 0 0. (a\*9)=(a\*8)+a = a2 a1 a0 a2 a1 a0 = aa(in 6 bit format). Hence in this case no hardware realization is required. The synthesized netlist of this design is shown below:<br/>

![mult_8_netlist_dia](https://github.com/user-attachments/assets/2142c87c-1d38-4ce8-9ae9-921f5d422a38)
![Screenshot from 2024-10-21 15-50-44](https://github.com/user-attachments/assets/1c769ec0-e2b6-48a1-bd97-f3388322b663)


### DAY 3 :-  : Combinational and Sequential Optimisations

#### Introduction to optimization
Optimization plays an important while we design any hardware. It reduces number of components which inturn reduces size and improves performance. Many times, we come across an expression which by simplification reduces to a either simple variable or a constant value through reduction of unsued variables.<br/>

### **Combinational Optimisations**
The techniques used for optimising the combinational Circuits are as follows:
1. Constant Propagation (Direct Optimisation)
2. Boolean Logic Optimisation (using K-Map or Quine McCluskey method)

#### **1. Constant Propagation Illustration**
Consider the combinational circuit shown below :<br/>

![image](https://github.com/user-attachments/assets/905952a7-badf-48f2-9739-bec193068649)

The boolean logic inferred is Y = ((AB)+C)'. If A is always tied to ground i.e., A = 0, then the expression will always evaluate to C'. In this case instead of having a AND gate and a NOR gate the circuit can be simplified by using a single NOT gate with C as its input. Even though both of then represent the same logic since the number of transistors used in the optimised design is less compared to that of the given circuit which shown in the above figure. The transistor level implementation of the given circuit and the optimised circuit is shown below :<br/>

![image](https://github.com/user-attachments/assets/17a7e4b8-62c9-4f13-9bcb-f4e0d417373c)

![image](https://github.com/user-attachments/assets/c5916b2b-da6e-449f-af90-b196ee8b1bc2)

The circuit that is given is implemented in NAND logic in order to prevent the stacking of the pmos. The transistor implementation clearly demonstrates a reduction in the required number of transistors for designing, decreasing from 12 to 2 in the optimised design. This will result in reduced power consumption and occuppies less area.<br/>

#### **2. Boolean Logic Optimisation Illustration**
Consider the verilog statement below : <br/>
```
assign y = a?(b?c:(c?a:0)):(!c);
```
The ternary operator **(?:)** will realize a mux upon synthesis. The combinational circuit that corresponds to the above statement is shown below:<br/>

![image](https://github.com/user-attachments/assets/b8cb369d-8a91-4d69-bd4b-afaa481df3ef)

This circuit can be optimised by writing the equivalent expression (or function) in boolean variables and minimising the function that will result in more optimised design which is shown below:<br/>

![image](https://github.com/user-attachments/assets/a8d19d84-88bd-4c4a-befd-d43ada2c36b8)

### **Sequential Optimisations**

The sequential logic optimisations techniques are broadly classified into two categories :
1. Basic Techniques
	a. Sequential Constant Propagation
2. Advanced Techniques
	a. State Optimisation
	b. Retiming
	c. Sequential Logic Cloning (Floor aware Synthesis)

#### **1. Sequential Constant Propagation**
Consider the sequential circuit shown below :<br/>

![image](https://github.com/user-attachments/assets/a353899b-472a-4aac-b5a9-89018d67453a)

The D flip-flop shown in the figure is positive edge triggered with asynchronous reset and the data input D is always tied to the ground (i.e, low state or logic 0). When reset is applied the output of the flop becomes low and if reset it deasserted the output of the flop still remains low. Hence one of the input to the NAND gate is always low resulting in the output Y to be always in high stae (logic 1 or VDD). Hence the optimised version of this circuit is connecting the output port Y directly to VDD i.e., the supply voltage.<br/>

___
***Note***: </br>
Consider the circuit shown below :<br/>
![image](https://github.com/user-attachments/assets/dc4faa66-fb25-4afc-9d95-6a2e5854ab15)

This circuit is similar to the one that is discussed above except that it doesn't have asynchronous reset instead it has asynchronous set. When the set input is logic 1 then output of the flop i.e., Q becomes high otherwise Q follows D input which is logic 0. This circuit can't be optimised like the previous circuit discussed in the above section. Consider the waveform between timestamp 1 and timestamp 2, the set pin is deasserted before the rising edge of the clock. The output Q remains high until the next rising edge even though the set input is deasseretd. The output of thr flop Q makes transition only at timestamp2. Therefore set input must be considered as Q'. This circuit can't be optimised.
___

#### **2. State Optimisation**
State optimization refers to the process of minimizing the number of unused states in a digital circuit's state machine.<br/>

#### **3. Sequential Logic Cloning**
Sequential logic cloning is used to replicate or clone a portion of a sequential logic circuit while maintaining its functionality and behavior. The goal is to exploit the benefits of parallelism and redundancy while ensuring that the cloned circuit produces identical outputs to the original circuit for the same inputs.<br/>
This technique is commonly employed in various scenarios such as redundancy for fault tolerance, speed improvement, and power optimization. This technique is generally used when a physical aware synthesis is done.<br/>

Consider the circuit shown below : <br/>

![image](https://github.com/user-attachments/assets/c11a2fdf-8802-4302-b7c0-5144b959c9c6)

Consider flop A has large positive slack. The flops B and C are far from flop A. Hence there will be a large routing delay from A to B and A to C. To avoid this flop A and the combinational logic 2 is replicated  or cloned in the paths of B and C as shown in the figure below. Since flop A has large positive slack the delay introduced because of the cloning will be compensated and the further delay in the circuit is mainly depended on flop B and flop C.<br/>

![image](https://github.com/user-attachments/assets/feed5c9a-86f9-415c-a7f4-7dc4ad24a3a8)

#### **4. Retiming**
Retiming  used to improve the performance interms of better timing characteristics by repositioning the registers (flip-flops) within the circuit without altering its functionality. In a digital circuit, registers (flip-flops) are used to store intermediate results and control the flow of data. The placement of these registers can significantly impact the circuit's overall performance, including its critical path delay, clock frequency, and power consumption. Retiming aims to optimize these factors by moving registers to appropriate locations within the circuit.

Consider the circuit shown below :<br/>

![image](https://github.com/user-attachments/assets/06efcb0a-6873-483a-83e3-420d8956a52f)

Consider the C-Q delay and set up time is 0ns. The combinational circuits have finite amount of the propagation delay. The maximum clock frequency with which the circuit operates depends on the propagation delay of the combinational logic. From flop A to B the propagation delay is 5ns and the maximum frequency with which this portion of circuit can be operated is 200MHz. Fom flop B to C the propagation delay is 2ns and the maximum frequency with which this portion of circuit can be operated is 500MHz. The effective frequency is minimum of the both which is 200MHz.<br/>

Suppose some part of the logic from combinational circuit between flop B and C is placed with the combinational circuit between the flop A and flop B in such a way that the propagation delay of the circuit between flop A and flop is reduced while propagation delay between flop B and flop C is increased by a small amount as show below :<br/>

![image](https://github.com/user-attachments/assets/5a7a2df7-982d-48ef-ab00-80b2e8af7d41)

The maximum frequency with which the portion of circuit between A and B can be operated is 250MHz and the maximum frequency with which the portion of circuit between B and C can be operated is 333MHz. The effective frequency is minimum of the both which is 250MHz. Thus the effective maximum frequency has increased after performing the retiming.<br/>

### **Illustration of Combinational Optimizsation:**

**Steps to generate the netlist for the below designs**

Generating netlist steps :
```
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib  
read_verilog <module_name.v> 
synth -top <top_module_name>
# flatten # Use if multiple modules are present
opt_clean -purge
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
write_verilog -noattr <netlist_name.v>
```

___
**opt_clean** - remove unused cells and wires. The ***-purge*** switch removes internal nets if they have a public name. This command identifies wires and cells that are unused and removes them.  This command can be used to clean up after the commands that do the actual work.
___

#### **Example 1**
The verilog code for the example 1 is given below :
```
module opt_check (input a , input b , output y);
	assign y = a?b:0;
endmodule
```
The above code infers a multiplexer as shown below :<br/>
![image](https://github.com/user-attachments/assets/21868ef2-c316-4aaf-996e-6174a0ee0d07)

Since one of the inputs of the multiplexer is always connected to the ground it will infer an AND gate on optimisation.<br/>

![image](https://github.com/user-attachments/assets/c326f1fd-2ed9-47f3-bfe7-caeb02ef5a06)

The synthesis result and the netlist are shown below :<br/>
![opt_check_net_dia](https://github.com/user-attachments/assets/54120e64-105c-4191-aa5e-ac914dd0401a)
![Screenshot from 2024-10-21 16-11-19](https://github.com/user-attachments/assets/b31e8ac6-8b61-4513-ad9f-c3c169200452)

#### **Example 2**
The verilog code for the example 2 is given below :
```
module opt_check2 (input a , input b , output y);
	assign y = a?1:b;
endmodule
```
The above code infers a multiplexer as shown below :<br/>
![image](https://github.com/user-attachments/assets/d705fffd-5ab2-4969-b00b-24c1e931cc3b)


Since one of the inputs of the multiplexer is always connected to the logic 1 it will infer an OR gate on optimisation. The OR gate will be NAND implementation since NOR gate has stacked pmos while NAND implementation has stacked nmos.<br/>

![image](https://github.com/user-attachments/assets/be7066b3-f847-48d8-9541-e01f2273746d)

The synthesis result and the netlist are shown below :<br/>
![opt_check2_net_dia](https://github.com/user-attachments/assets/2d2e5540-55e3-47f8-9125-331523e0f682)
![Screenshot from 2024-10-21 16-12-52](https://github.com/user-attachments/assets/490e7104-9f1d-4159-ac69-335cde647f31)

#### **Example 3**
The verilog code for the example 3 is given below :
```
module opt_check3 (input a , input b, input c , output y);
	assign y = a?(c?b:0):0;
endmodule
```
The above code infers two multiplexers as shown below : <br/>

![image](https://github.com/user-attachments/assets/f4b85ca5-596e-4b2e-9df2-148206394e62)

On optimisation the above design becomes a 3 input AND gate as shown below :<br/>

![image](https://github.com/user-attachments/assets/b65bdbf4-e449-42c9-96cc-b9b7e22d5079)

The synthesis result and the netlist are shown below :<br/>
![opt_check3_net_dia](https://github.com/user-attachments/assets/106a9a48-cf86-4c19-8ad0-704ef8dd6b7f)
![Screenshot from 2024-10-21 16-14-27](https://github.com/user-attachments/assets/fa91ad2d-db47-432a-9147-aa9acc9b4b3d)

#### **Example 4**
The verilog code for the example 4 is given below :
```
module opt_check3 (input a , input b, input c , output y);
	assign y = a?(c?b:0):0;
endmodule
```
The above code infers two multiplexers as shown below : <br/>

![image](https://github.com/user-attachments/assets/6b8574ba-6f6b-43b1-979d-a04936515a69)

On optimisation the above design becomes a 2 input XNOR gate as shown below :<br/>

![image](https://github.com/user-attachments/assets/4be4ffdd-72ea-4799-970e-df42a339b81b)

The synthesis result and the netlist are shown below :<br/>
![opt_check4_net_dia](https://github.com/user-attachments/assets/80165ad5-afb4-4123-abc1-93a598fe3b36)
![Screenshot from 2024-10-21 16-15-46](https://github.com/user-attachments/assets/e1c8cd28-cb8e-44a5-9fa8-7232aef3bb14)

#### **Example 5**
The verilog code for the example 5 is given below :
```
module sub_module1(input a , input b , output y);
 assign y = a & b;
endmodule


module sub_module2(input a , input b , output y);
 assign y = a^b;
endmodule


module multiple_module_opt(input a , input b , input c , input d , output y);
wire n1,n2,n3;

sub_module1 U1 (.a(a) , .b(1'b1) , .y(n1));
sub_module2 U2 (.a(n1), .b(1'b0) , .y(n2));
sub_module2 U3 (.a(b), .b(d) , .y(n3));

assign y = c | (b & n1); 


endmodule
```

The circuit inferred by the code is shown below : <br/>

![image](https://github.com/user-attachments/assets/5987bb02-47d9-4bef-83f0-44971fe8716e)

On optimisation the above design becomes a AND OR gate as shown below :<br/>

![image](https://github.com/user-attachments/assets/13a3dfbb-0ac5-4155-9f9b-5508f5df9539)

The synthesis result and the netlist are shown below :<br/>
![multiple_modules_net_dia](https://github.com/user-attachments/assets/085b8c57-b266-4a34-8ac7-4e5e19eae2a1)
![Screenshot from 2024-10-21 16-19-46](https://github.com/user-attachments/assets/986760da-3db4-4caa-8c78-fad3f6d65e07)
![Screenshot from 2024-10-21 16-20-48](https://github.com/user-attachments/assets/e5be6ca3-9e10-4303-9ec7-20b86e4dc114)

#### **Example 6**
The verilog code for the example 6 is given below :
```
module sub_module(input a , input b , output y);
 assign y = a & b;
endmodule



module multiple_module_opt2(input a , input b , input c , input d , output y);
wire n1,n2,n3;

sub_module U1 (.a(a) , .b(1'b0) , .y(n1));
sub_module U2 (.a(b), .b(c) , .y(n2));
sub_module U3 (.a(n2), .b(d) , .y(n3));
sub_module U4 (.a(n3), .b(n1) , .y(y));


endmodule
```

The circuit inferred by the code is shown below : <br/>

![image](https://github.com/user-attachments/assets/b5b156d8-7756-49bc-9f57-07e02a300be0)

On optimisation the above design becomes a direct connection of ground (logic 0) to output as shown below :<br/>

![image](https://github.com/user-attachments/assets/080d1ffc-5633-4317-ae2b-62ed1fd2743f)

The synthesis result and the netlist are shown below :<br/>
![multiple_modules_opt2_net_dia](https://github.com/user-attachments/assets/06901044-5f40-41f7-951a-276fcfbaccfb)
![Screenshot from 2024-10-21 16-24-30](https://github.com/user-attachments/assets/f7752f67-e924-40ee-8776-5bc78d114503)
![Screenshot from 2024-10-21 16-24-50](https://github.com/user-attachments/assets/fb00c368-0505-40c5-9eea-cf7e8af9b2d6)


### **Illustration of Sequential Optimizsation:**

**Steps to simulate and generate the netlist for the below designs**

Simulation steps :
```
iverilog <rtl_name.v> <tb_name.v>
./a.out
gtkwave <dump_file_name.vcd>
```

Generating netlist steps :
```
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib  
read_verilog <module_name.v> 
synth -top <top_module_name>
# flatten # use if the multiple modules are present
opt_clean -purge
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
write_verilog -noattr <netlist_name.v>
```

#### **Example 1**
The verilog code for the example 1 is given below :
```
module dff_const1(input clk, input reset, output reg q);
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b0;
	else
		q <= 1'b1;
end

endmodule
```
The above code infers the circuit as shown below :<br/>

![image](https://github.com/user-attachments/assets/210f2db1-6859-4f7c-977d-c7e4233114e9)

Since this code doesn't need optimisation it will infer a D flip-flop with asynchronous reset as shown above.<br/>

The simulation, synthesis result and the netlist are shown below :<br/>
![dff_const1_wav](https://github.com/user-attachments/assets/ca2e38cb-b07f-44ab-a82e-e431646be1f4)
![dff_const1_net_dia](https://github.com/user-attachments/assets/d82b5b3d-8bb8-4c1b-b3bb-2c0a5ab0e4c0)
![Screenshot from 2024-10-21 16-29-01](https://github.com/user-attachments/assets/dac9ed4c-587a-4914-9441-3f98cfa70bee)
All the standard cells by default have negative logic for reset and since in the code reset is mentioned as positive, an inverter is used for the reset signal. <br/>

#### **Example 2**
The verilog code for the example 2 is given below :
```
module dff_const2(input clk, input reset, output reg q);
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b1;
	else
		q <= 1'b1;
end
endmodule
```
The above code infers a D flip-flop with asynchronous set (reset signal is applied to set input) as shown below :<br/>

![image](https://github.com/user-attachments/assets/59c8bddb-9c8e-4767-b2b7-cc1c8caa6ce1)

The optimised design infers a direct connection of VDD (logic 1) to the output q as shown below:<br/>

![image](https://github.com/user-attachments/assets/4c74eb2c-5662-4871-bc5e-cba78e622e9d)

The simulation, synthesis result and the netlist are shown below :<br/>
![dff_const2_wave](https://github.com/user-attachments/assets/3c2da608-ebad-4fc8-a051-97a5e6edc80f)
![dff_const2_net_dia](https://github.com/user-attachments/assets/ec2b0b83-f7e7-4791-ae30-6be476b2cd63)
![Screenshot from 2024-10-21 16-40-58](https://github.com/user-attachments/assets/c21e6879-1a15-41c4-99af-56f8c7366c0a)

#### **Example 3**
The verilog code for the example 3 is given below :
```
module dff_const3(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end

endmodule
```
The above code infers a two D flip-flop with asynchronous set and reset (reset signal is applied to set and reset input) as shown below :<br/>

![image](https://github.com/user-attachments/assets/2e5be62f-3722-4cc9-af6e-6f4b86dcb199)

Since this code doesn't need optimisation it will infer two D flip-flop with asynchronous set and reset as shown above.<br/>

The simulation, synthesis result and the netlist are shown below :<br/>
![dff_const3_wave](https://github.com/user-attachments/assets/77b3ebe7-44f3-4443-ac2f-31ea176f3407)

At the timestamp 1550 the signal q1 changes from 0 to 1 but the output q transits from 1 to 0 for a clock cycle. It is because there will be a finite clock to q delay so the second flip-flop will sample the logic 0 at that rising edge of the clock. Hence there is a change in the output signal for one clock cycle.<br/>

![dff_const3_net_dia](https://github.com/user-attachments/assets/4f2cefe2-d55d-407b-9d5e-872033897950)
![Screenshot from 2024-10-21 16-43-18](https://github.com/user-attachments/assets/9f695e68-31b1-45f1-bd31-f9b9ea709fb4)

#### **Example 4**
The verilog code for the example 4 is given below :
```
module dff_const4(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b1;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end

endmodule
```
The above code infers a two D flip-flop with asynchronous set(reset signal is applied to set input ) as shown below :<br/>

![image](https://github.com/user-attachments/assets/acaae055-4ce9-458b-8b77-b80ca17bf140)

The optimised design infers a direct connection of VDD (logic 1) to the output q as shown below:<br/>
![image](https://github.com/user-attachments/assets/80ff488d-d6c9-476b-aa02-cb88008ce014)

The simulation, synthesis result and the netlist are shown below :<br/>
![dff_const4_wave](https://github.com/user-attachments/assets/92f09aeb-2f23-4695-bf73-dee8b15716c7)
![dff_const4_net_dia](https://github.com/user-attachments/assets/9091fcf5-c804-4f19-86a5-c4dd5cacb052)
![Screenshot from 2024-10-21 16-45-18](https://github.com/user-attachments/assets/ad3481bc-9116-408d-9048-a29669e2d4c3)

#### **Example 5**
The verilog code for the example 5 is given below :
```
module dff_const5(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b0;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end

endmodule
```


The above code infers a two D flip-flop with asynchronous reset  as shown below :<br/>

![image](https://github.com/user-attachments/assets/dd277eb4-2d80-4795-8b65-0b6fdad7d864)

Since this code doesn't need optimisation it will infer two D flip-flop with asynchronous reset as shown above.<br/>


The simulation, synthesis result and the netlist are shown below :<br/>
![dff_const5_wave](https://github.com/user-attachments/assets/f91dfd80-2090-4b30-ba69-6b475ad3fcac)
![dff_const5_net_dia](https://github.com/user-attachments/assets/a6d9457d-32d3-4266-8119-7325cca17e60)
![Screenshot from 2024-10-21 16-46-37](https://github.com/user-attachments/assets/946ee08f-5d1d-42e1-a733-3f3a141fa931)


### **Optimisation of Unused States**

**Steps to simulate and generate the netlist for the below designs**

Simulation steps :
```
iverilog <rtl_name.v> <tb_name.v>
./a.out
gtkwave <dump_file_name.vcd>
```

Generating netlist steps :
```
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib  
read_verilog <module_name.v> 
synth -top <top_module_name>
opt_clean -purge
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
write_verilog -noattr <netlist_name.v>
```


Consider the verilog code shown below :
```
module counter_opt (input clk , input reset , output q);
reg [2:0] count;
assign q = count[0];

always @(posedge clk ,posedge reset)
begin
	if(reset)
		count <= 3'b000;
	else
		count <= count + 1;
end

endmodule
```

This verilog code will infer a 3-bit counter with asynchronous reset.
The possible states of the counter are as follows :
| count[2] count[1] count[0]  |COUNT[2] COUNT[1] COUNT[0] |
|:---:|:---:|
| 0 0 0 | 0 0 1  |
| 0 0 1 | 0 1 0 |
| 0 1 0 | 0 1 1 |
| 0 1 1 | 1 0 0 |
| 1 0 0 | 1 0 1 |
| 1 0 1 | 1 1 0 |
| 1 1 0 | 1 1 1 |
| 1 1 1 | 0 0 0 |

where </br>
count - Previous count</br>
COUNT - Preset count

Since the output q is always assigned COUNT[0]. The other bits of the count are not used and not required. Instead of infering three flip-flops , on optimising the design it will infer a single D flip-flop and an inverter as shown below :<br/>

![image](https://github.com/user-attachments/assets/379ace4f-cdba-455a-bed2-fae0ea89e241)

The simulation, synthesis result and the netlist are shown below :<br/>
![counter_opt_wave](https://github.com/user-attachments/assets/67792bad-5a01-4182-b084-cb4e78080295)
![counter_opt_net_dia](https://github.com/user-attachments/assets/bd91a14b-fad0-4610-bd2c-e7528a7c8e89)
![Screenshot from 2024-10-21 16-50-22](https://github.com/user-attachments/assets/bd6691e7-9553-4e20-918b-78c2bccb2391)


Consider another verilog code shown below :
```
module counter_opt (input clk , input reset , output q);
reg [2:0] count;
assign q = count==3'b100;

always @(posedge clk ,posedge reset)
begin
	if(reset)
		count <= 3'b000;
	else
		count <= count + 1;
end

endmodule
```
In this case since q is asserted only when count == 3'b100, all the three flip-flops are used. Hence even after optimisation , the code will infer three flops.<br/>

The simulation, synthesis result and the netlist are shown below :<br/>
![Screenshot from 2024-10-21 16-54-45](https://github.com/user-attachments/assets/67818dd8-09c9-4a0b-8611-d4e752d36932)
![counter_opt2_net_dia](https://github.com/user-attachments/assets/a65813e0-84d9-47dd-921d-765b6be23b0f)
![Screenshot from 2024-10-21 16-52-16](https://github.com/user-attachments/assets/41da7429-9189-43d1-bae1-8b348e5718bd)
![Screenshot from 2024-10-21 16-52-42](https://github.com/user-attachments/assets/f2b0f7db-0d3f-47b9-8454-77c9a0a45faf)

## Day - 4 : Gate Level Simulation (GLS), Blocking Vs Non-blocking assignment and Synthesis-Simulation Mismatch

### **Gate Level Simulation**
Gate Level Simulation helps ensure that the synthesized version of the design matches the specification both in terms of functionality and  timing. It helps identify mistakes and differences in the synthesised netlist and ensures that the final design functions as intended. Generally GLS is done to ensure that there is no synthesis-simulation mismatch. To perform the GLS the testbench that is used to verify the RTL is used. The GLS flow is similar to the testbench flow except that gate level verilog models are also used. It is necessary to mention the gatelevel verilog models  to iverilog to make the iverilog understand about the standard cell given in the library .GLS requires adding information about timing delays. Gate level Verilog models can be functional and timing aware. If the gate level models are delay annotated then it can used for timing validation. 

![image](https://github.com/user-attachments/assets/15981d61-54c5-4c67-aca8-c767cc204bce)

### **Synthesis-Simulation Mismatch**
Synthesis-simulation mismatch refers to the differences between the behavior of a digital circuit as simulated at the Register Transfer Level (RTL) and its behavior after being synthesized to gate-level netlists. Synthesis-simulation mismatch can occur because of the following reasons:
1. Missing Sensitivity List
2. Blocking vs Non-blocking assignments
3. Non standard verilog coding

#### **1. Missing Sensitivity List**

Consider the verilog code and its corresponding graph shown below :
```
module mux(
	input i0,i1,s,
	output reg y
)
	always @(sel) begin
		if(sel)
			y = i1;
		else
			y = i0;
	end
endmodule
```
![image](https://github.com/user-attachments/assets/b320b10a-c8bf-411a-a887-76adab21a779)

The "always" block is sensitive only to the "sel" signal. Whenever there's a modification in the "sel" output, it triggers a change in the output value. However, as this piece of code implies a multiplexer, the output should also change if the input changes. Since the sensitivity list includes only "sel," the output remains unaffected and it doesn't follow the input i0 when the sel is logic 0. Hence this a circuit behaves like a latch.<br/>

In order to solve the problem all the critical signals needed to be mentioned in the sensitivity list. So the corrected code is given below :
```
module mux(
	input i0,i1,s,
	output reg y
)
	always @(*) begin //* - It considers changes in all the input signals. So always is evaluated whenever any signal changes.
		if(sel)
			y = i1;
		else
			y = i0;
	end
endmodule
```
#### **2. Blocking and Non-Blocking Statements in Verilog**

Blocking and Non-Blocking statemnets are very important statements. They must used with utmost care so that intended logic is created. These statements are used inside the always block.
**1. Blocking Assignment:**
Blocking assignments are denoted using the "=" operator. When a blocking assignment is executed, it directly assigns the right-hand side value to the left-hand side variable immediately within the current simulation cycle. The subsequent statements in the procedural block  will wait for this assignment to complete before proceeding. Blocking assignments are sequentially executed.

**2. Non-blocking Assignment:**
Non-blocking assignments are denoted using the "<=" operator. When a non-blocking assignment is encountered, the right-hand side value is scheduled to be assigned to the left-hand side variable at the end of the current simulation cycle. This means that all non-blocking assignments within a procedural block are executed simultaneously, updating variables concurrently. The value changes take effect in the next simulation cycle. Non-Blocking assignments are executed in parallel.

#### **Caveats with Blocking Assignment**
**Example 1**
Consider the verilog code given below:
```
module code(
	input clk,reset,d,
	output reg q
)
	reg q0;
	always @(posedge clk, posedge reset) begin
		if(reset) begin
			q=1'b0;
			q0=1'b0;
		end
		else begin
			q = q0; //Line 1
			q0=d; // Line 2
		end
	end
endmodule
```
The inetent of this code is to create a 2-bit shift register. Since blocking assignmnet is used for Line 1 and Line 2 both the lines will be executed sequentially. First line 1 will be executed creating a flip-flop whose input is q0 and output is q. Then line 2 will be executed which creates a second flip-flop whose input is d and output is q0 thereby connecting two flip-flops and creating a 2-bit shift register shown below:<br/>

![image](https://github.com/user-attachments/assets/a52e63d3-acf7-477c-94d3-e71b3bc289ec)

Consider the verilog code shown below :
```
module code(
	input clk,reset,d,
	output reg q
)
	reg q0;
	always @(posedge clk, posedge reset) begin
		if(reset) begin
			q=1'b0;
			q0=1'b0;
		end
		else begin
			q0 = d; //Line 1
			q=q0; // Line 2
		end
	end
endmodule
```
This code looks similar to the previous one except that line 1 and line 2 are interchanged. Since , blocking assignment is used line 1 and line 2 will be executed sequentially. First line 1 will be executed which creates a D flip-flop with the input d and output q0, then line 2 is executed. Since q0 is already defined assigning q0 to q creates wire . Hence only flip-flop is inferred instead of two. The circuit corresponding to the code is shown below :<br/>

![image](https://github.com/user-attachments/assets/f322cb8d-b43d-4525-ab30-776b5a0b09f2)

**Example 2**
Consider the verilog code shown below :
```
module(
	input a,b,c,
	output reg y
)
	reg q0;
	always @(*) begin
		y = q0 & c; //Line 1
		q0 = a|b; //Line 2
	end
endmodule
```
In line 1 the output y is assigned with q0&c. But q0 is not mentioned anywhere before. Hence the previous value of the q0 will be taken and this will not infer a combinational circuit as expected instead a latch based circuit will be inferred. The corrected version of the code is shown below:
```
module(
	input a,b,c,
	output reg y
)
	reg q0;
	always @(*) begin
		q0 = a|b; //Line 1
		y = q0 & c; //Line 2
		
	end
endmodule
``` 

### **Illustration of GLS and Synthesis Simulation Mismatch**

**Steps to simulate, generate the netlist and to perform the GLS for the below designs**

Simulation steps :
```
iverilog <rtl_name.v> <tb_name.v>
./a.out
gtkwave <dump_file_name.vcd>
```

Generating netlist steps :
```
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib  
read_verilog <module_name.v> 
synth -top <top_module_name>
# opt_clean -purge # If optimisation has to be done
# dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib # if sequential circuit is used 
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
show
write_verilog -noattr <netlist_name.v>
```

Steps to perform GLS:
```
iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v <netlist_name.v> <tb_name.v>
./a.out
gtkwave <dump_file_name.vcd>
```

#### **Example 1**
Consider the verilog code shown below :
```
module ternary_operator_mux (input i0 , input i1 , input sel , output y);
	assign y = sel?i1:i0;
endmodule
```
In verilog ternary operator will realize  multiplexer upin synthesis. If the operand left of the ? is true then output follows the immediate operand right of  ? otherwise the ouput follows the immediate operand to the right of :.

The simulation, synthesis result , the netlist and the GLS are shown below :<br/>
![ternary_operator_mux_code](https://github.com/user-attachments/assets/924471b0-d3dd-45e9-98ff-e91fa8ae756c)
![ternary_operator_mux](https://github.com/user-attachments/assets/c615a34b-1be6-4d9d-b42b-13b2976d400e)
![ternary_operator_mux_net_dia](https://github.com/user-attachments/assets/cdba79f5-544e-40c4-9243-6981d28d3ce9)
![tern_net](https://github.com/user-attachments/assets/cf56072d-5128-48d7-b08c-be7458cd501c)

Simulation Waveform after performing the netlist generated file  with testbench<br/>
![ternary_operator_mux_terminal_pic](https://github.com/user-attachments/assets/6a28f3cb-1e2c-40e5-90ee-ad94b4ccb058)
![ternary_operator_netlist_wave](https://github.com/user-attachments/assets/8d9ffee8-73f8-4b9a-819b-3bcf96d80513)

In this case there is no synthesis and simulation mismatch.

#### **Example 2**
Consider the verilog code shown below :
```
module bad_mux (input i0 , input i1 , input sel , output reg y);
always @ (sel)
begin
	if(sel)
		y <= i1;
	else 
		y <= i0;
end
endmodule
```
This code only has sel signal in sensitivity list. Hence the RTL simulation output will not match the expected specification.

The simulation, synthesis result , the netlist and the GLS are shown below :<br/>
![bad_mux_wave](https://github.com/user-attachments/assets/b9c18a47-e322-4a49-bfc5-beab5a8c4a18)
![bad_mux_net_dia](https://github.com/user-attachments/assets/9a321eb6-45f4-438c-bedc-857daa79092a)
![bad_net](https://github.com/user-attachments/assets/f3c70933-2b04-4584-b6a1-bc8a40e2eb7b)
![bad_mux_net_wave](https://github.com/user-attachments/assets/345b8206-15da-4eef-aba9-4d0aa8dd4a05)

In this case there is a synthesis and simulation mismatch. While performing synthesis yosys has corrected the sensitivity list error.

#### **Example 3**
Consider the verilog code shown below :
```
module blocking_caveat (input a , input b , input  c, output reg d); 
reg x;
always @ (*)
begin
	d = x & c; //Line 1
	x = a | b; //Line 2
end
endmodule
```
This code only has signal x in line which is not defined before. Hence the previous value of x will be taken and the expression will be evaluated. Hence the RTL simulation output will not match the expected specification and will infer a latch based circuit instead of the combinational circuit.<br/>

The simulation, synthesis result , the netlist and the GLS are shown below :<br/>
![blocking_caveat_wave](https://github.com/user-attachments/assets/c2876f32-16a2-4dde-9d30-b31cc96f75db)
![blocking_caveat_net_dia](https://github.com/user-attachments/assets/381ce760-3a91-4622-a3a1-54c786f678b3)
![blocking_net](https://github.com/user-attachments/assets/b2718348-6412-4864-a483-c252fd0c828e)
![blocking_caveat_net_wave](https://github.com/user-attachments/assets/ef4e729c-b001-4c76-a789-ecab8a4b7238)

In this case there is a synthesis and simulation mismatch. While performing synthesis yosys has corrected the latch error.


# LAB 11 
### Synthesizing VSDBABYSOC RISC-V based design which is basically the post synthesizing the riscv core which we did in [LAB 9](#lab-9). My rvmyth file is riscv_chandan.v.<br/>

In this lab task we requires the riscv_core file which we used in the previous lab. The filename i am using is riscv_chandan.v, testbench.v, vsdbabysoc.v - as a top module, clk_gate.v and some of the library files like sky130_fd_sc_hd__tt_025C_1v80.lib, avsddac.lib, avsdpll.lib. <br/>

At first, we have to keep all the files in the one directory for easy access while synthesizing it like keeping all the .vh files also. Then open the terminal at that directory and follow the below steps:-<br/>
```
yosys
read_liberty -lib sky130_fd_sc_hd__tt_025C_1v80.lib
read_liberty -lib avsddac.lib
read_liberty -lib avsdpll.lib
read_verilog vsdbabysoc.v
read_verilog riscv_chandan.v
read_verilog clk_gate.v
synth -top vsdbabysoc
dfflibmap -liberty sky130_fd_sc_hd__tt_025C_1v80.lib 
abc -liberty sky130_fd_sc_hd__tt_025C_1v80.lib 
show vsdbabysoc
write_verilog -noattr vsdbabysoc.synth.v
```

The general steps are like:-<br/>
```
yosys
read_liberty -lib <sky_130_datapath.lib>
read_liberty -lib <avsddac_datapath.lib>
read_liberty -lib <avsdpll_datapath.lib>
read_verilog <module_name.v>
# read_verilog <module_name.v> #use how many modules you should instantiate based on that read it
synth -top <top_module_name>
dfflibmap -liberty <sky130_datapath.lib>
abc -liberty <sky130_datapath.lib>
show <top_module_name>
write_verilog -noattr <netlist_name.v>
```

The above commands are explained in [LAB 10](#lab-10) which are basically required for synthesis of a design if any doubts come with respect to the commands functionality please go through the above lab session.

The below pictures are the proof that i synthesized using my own machines terminal and also it contains the mapping of cells and also the statistics of it.<br/>
![11](https://github.com/user-attachments/assets/e16b1fe3-f4e8-4180-bfa4-a1f921d802a6)
![13](https://github.com/user-attachments/assets/323021be-e175-4d08-9298-790684ed53a0)
![14](https://github.com/user-attachments/assets/a9fc15e8-c850-43ee-b74c-9dc39e8b1482)
![15](https://github.com/user-attachments/assets/09c747ad-b163-457a-ae20-2771d9c982c5)
![16](https://github.com/user-attachments/assets/f1bb502c-b297-4194-9b78-a34ac7de9563)

The synthesized design is show as below:-<br/>
![image](https://github.com/user-attachments/assets/17a77b30-c28e-4271-bf67-a165443d333d)
![1111](https://github.com/user-attachments/assets/3a8447d2-dd10-4531-aa9a-ea3e5adc827d)

After completing these steps we have the synthesized netlist file which we have to simulate and view the waveform with the help of iverilog and gtkwave tool.<br/>

The following are the steps to be followed for getting the simulation waveform:-<br/>

```
mkdir -p output/post_synth_sim && iverilog -o output/post_synth_sim/post_synth_sim.out -DPOST_SYNTH_SIM -DFUNCTIONAL -DUNIT_DELAY=#1     -I src/module/include -I src/module -I src/gls_model     src/module/testbench.v && cd output/post_synth_sim && ./post_synth_sim.out
gtkwave post_synth_sim.vcd
```
Here, the POST_SYNTH_SIM directive is enabled and given to the testbench which includes all the files and simulates the sythesized netlist to generate the .vcd file. The waveform is shown below(for atleast 20 cycles):<br/>

![terminal](https://github.com/user-attachments/assets/d247226a-77d1-4576-9503-b8db7f962dc5)

The final waveform all these steps looks like this:-<br/><br/>
![1](https://github.com/user-attachments/assets/d96f6a73-4729-450b-840c-79567050a578)

Zoomed view<br/>
![2](https://github.com/user-attachments/assets/4b030182-fa6a-4706-827b-8d7ba899d9b8)

In the above given waveform picture i have specified the things which i specified in the previous lab that are:-<br/>
1. Clock with my name.<br/>
2. DAC output.<br/>
3. Waveform in analog view.<br/>
4. PLL.<br/>
5. Reset.<br/>
6. Riscv with 10 bits output.<br/>

The below picture specifies the thing that i used the netlist file for simulation because we can see standard cells which is not visible in normal rvmyth file while viewing the simulation.<br/>

![3](https://github.com/user-attachments/assets/b0fbfafc-995b-459a-9574-71f7aa3bb190)

For easy comparison with the previous lab waveform outputs and the present lab waveform outputs please refer the lab - 9 or go through the below figures:-<br/>

![1](https://github.com/user-attachments/assets/c9536ba0-fda0-4ebc-9c05-8e82d41e904c)

Note:- I have uploaded all the .v files which are mainly required for this lab please refer to it.

And at conclusion i am getting the same output as the previous lab by comparing both.

# LAB-12
### Static Timing Analysis for the vsdbabysoc, [which we designed in our previous labs] using OPENSTA tool. <br/>

The tasks for this lab given was to find the timing report for the previously generated synthesis file in lab-11. The given constraints are the setup uncertainty and clock transition must be 5% of the assigned clock, hold uncertainty and data transition must be 8% of the clock assigned. The clock time period assigned for me is "11.7ns".<br/>

And also for understanding the STA part we have to go through the 2 courses and then we can easily analyze the timing report.<br/>

The first course named " VSD static timing analysis I ", the link for this is https://www.udemy.com/share/101Gim3@DoG4fpDTIcqr4KUwcp3fBw_no9bOPanjxvr1vvf9GEQuc_IhNqUF6rdsuWArcAUn1w==/ .<br/>
In this course we learn about the :- <br/>
* Understand various STA checks for timing closure<br/>
* Able to do a quality analysis for real designs<br/>
* Know-how on how real STA works in industries, something which you will not find in any books<br/>
* Step-by-step and structured timing analysis<br/>

In overall conclusion we will learn the below things which is present in the below pictures fully.<br/>

![image](https://github.com/user-attachments/assets/eb68cc3d-64f3-489f-9f49-85f1807df89f)
![image](https://github.com/user-attachments/assets/c5083e47-7271-4291-9b8c-8afafa8274b0)


The second course named " VSD static timing analysis II ", the link for this is https://www.udemy.com/share/101KH83@9rL-RmRbgIlH4RXY3rGdPHsBneKRZYvILo5FCVFr-6zl4kmDQhg_UyigaVzhUs7_ew==/ . <br/>
In this course we learn about:- <br/>
 * We will be able to do a real full chip static timing analysis with $0 spent, as designs and tools used in this course are opensource<br/>
 * We will be able to appreciate power of opensource EDA tools, like Opentimer used in this course, and help in contributing towards the development<br/>
 * We can explore commercial tools with knowledge and concepts from this course, quite easily<br/>
 * Manage a entire chip timing signoff<br/>

 The tool used here for explaining is named as " OPENTIMER ", the link for downloading that file is https://github.com/OpenTimer/OpenTimer.git or else we can download the file from the course itself it will be provided their.<br/>

 Below is the picture of opentimer tool which we work in this course<br/>
![ot_terminal](https://github.com/user-attachments/assets/e483201f-3c4c-41ba-a480-0610bdab0d48)
![ot_terminal_1](https://github.com/user-attachments/assets/01b825d2-d1e9-400a-8175-843828e77471)

By using the above tool and some of the files which are also present in this course, we can run and see it how does it works and also can change the clock values.<br/>
The file which are used in this course are uploaded by me to this github repo you can check for confirmation.<br/>


After going through these 2 courses now we are able to understand the sta now we are using the previous lab's vsdbabysoc.synth.v file for sta analysis.<br/>

For making the things much easier we have a sta.conf file where all the commands for sta analysis is put in one file and run that single file.<br/>
The path we considered for the timing reports is reg2reg path, which will be understood if you see the previous lab synthesized netlist yosys graph. As specified by sir for this lab task we have to use the vsdbabysoc netlist that we created.<br/>
All the below analysis uses same reg2reg path.<br/>

Below are the steps i considered for the execution of sta:-<br/>
```
cd /home/ms2024007/VSDbabysoc/src/script/
sta sta.conf  # For directly running the sta analysis use this command
```
The sta.conf file consists of:-
```
read_liberty -min ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_liberty -max ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_liberty -min ../lib/avsdpll.lib
read_liberty -max ../lib/avsdpll.lib
read_liberty -min ../lib/avsddac.lib
read_liberty -max ../lib/avsddac.lib
read_verilog ../module/vsdbabysoc.synth.v
link_design vsdbabysoc
read_sdc ../sdc/vsdbabysoc_synthesis.sdc
report_checks -path_delay max -format full  # for finding the setup analysis "thought in course"
report_checks -path_delay min -format full  # for finding the hold analysis "thought in course" 
report_checks -path_delay max -format full > t1_setup2.txt # for saving it as a file
report_checks -path_delay min -format full > t2_hold2.txt  # for saving it as a file
```
In above commands read_sdc is the only new thing others all are explained in the previous labs. This sdc file consists of clock creation, setup timing and hold timing.<br/>
I have used two sdc file one with only creation of clock no other parameters are specified and other is fully specified one.<br/>

1st sdc file contains<br/>
```
set_units -time ns
create_clock [get_pins {pll/CLK}] -name clk -period 11.7
```
For this sdc file i got the below as the output<br/>

Setup analysis<br/>
![terminal1_1](https://github.com/user-attachments/assets/4023d024-c076-4051-962c-38821040b92b)

Hold analysis<br/>
![terminal2_2](https://github.com/user-attachments/assets/8aabd2b6-6457-4715-bf42-5100b4dc4af0)

Both are in positive as the slack is met because clock uncertainty is not mentioned so we are getting like these results.<br/>

2nd sdc file contains <br/>
```
# Create clock with new period
create_clock [get_pins pll/CLK] -name clk -period 11.7 -waveform {0 5.85} 

# Set loads
set_load -pin_load 0.5 [get_ports OUT] 
set_load -min -pin_load 0.5 [get_ports OUT] 

# Set clock latency
set_clock_latency 1 [get_clocks clk] 
set_clock_latency -source 2 [get_clocks clk] 

# Set clock uncertainty
set_clock_uncertainty 0.585 -setup [get_clocks clk]  ; # 5% of clock period for setup
set_clock_uncertainty 0.936 -hold [get_clocks clk] ; # 8% of clock period for hold

# Set maximum delay
set_max_delay 11.7 -from [get_pins dac/OUT] -to [get_ports OUT] 

# Set input delay for VCO_IN
set_input_delay -clock clk -max 4 [get_ports VCO_IN] 
set_input_delay -clock clk -min 1 [get_ports VCO_IN] 

# Set input delay for ENb_VCO
#set_input_delay -clock clk -max 4 [get_ports ENb_VCO] 
#set_input_delay -clock clk -min 1 [get_ports ENb_VCO] 

# Set input delay for ENb_CP
set_input_delay -clock clk -max 4 [get_ports ENb_CP] 
set_input_delay -clock clk -min 1 [get_ports ENb_CP] 

# Set input transition for VCO_IN
set_input_transition -max 0.585 [get_ports VCO_IN] ; # 5% of clock
set_input_transition -min 0.234 [get_ports VCO_IN] ; 

# Set input transition for ENb_VCO
#set_input_transition -max 0.585 [get_ports ENb_VCO] ; # 5% of clock
#set_input_transition -min 0.234 [get_ports ENb_VCO] ; 

# Set input transition for ENb_CP
set_input_transition -max 0.585 [get_ports ENb_CP] ; # 5% of clock
set_input_transition -min 0.234 [get_ports ENb_CP] ;

```
While using the 2nd sdc file i have change the sta.conf file as:-<br/>
```
read_liberty -min ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_liberty -max ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_liberty -min ../lib/avsdpll.lib
read_liberty -max ../lib/avsdpll.lib
read_liberty -min ../lib/avsddac.lib
read_liberty -max ../lib/avsddac.lib
read_verilog ../module/vsdbabysoc.synth.v
link_design vsdbabysoc
read_sdc ../sdc/vsdbaby_syn1.sdc
report_checks -path_delay max -format full  # for finding the setup analysis "thought in course"
report_checks -path_delay min -format full  # for finding the hold analysis "thought in course" 
report_checks -path_delay max -format full > t1_setup2.txt # for saving it as a file
report_checks -path_delay min -format full > t2_hold2.txt  # for saving it as a file
```
Again for running this use below command:-<br/>
```
cd /home/ms2024007/VSDbabysoc/src/script/
sta sta1.conf  # For directky running the sta analysis use this command
```
For 2nd sdc file i got below outputs:-<br/>

Setup analysis<br/>
![teminal1](https://github.com/user-attachments/assets/c368ad06-d34e-485d-99c0-a80c93ce6c77)

Hold analysis<br/>
![terminal2](https://github.com/user-attachments/assets/26273c24-dc5f-421d-939e-bbff453e418a)

Here we get negative slack and we have been violated in both setup and hold analysis, that means the design needs to be modified to reduce the path delays or the clock frequency under consideration needs to be increased to match the delays.<br/>

The files are also uploaded with respect to this lab. <br/>





  
    

## References:

*  https://forgefunder.com/~kunal/riscv_workshop.vdi
*  https://gcc.gnu.org/onlinedocs/gcc/RISC-V-Options.html
*  https://github.com/vinayrayapati/rv32i
*  [https://github.com/stevehoover](https://github.com/stevehoover/RISC-V_MYTH_Workshop)
*  https://makerchip.com/sandbox
*  https://gcc.gnu.org/onlinedocs/gcc/RISC-V-Options.html
*  https://github.com/manili/VSDBabySoC.git
*  https://github.com/KanishR1/Introduction-to-ASIC-Flow.git
*  https://github.com/bhargav-vlsi/ASIC-Design-IIITB.git
*  https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git

  
  
